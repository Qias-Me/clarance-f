Please create a Product Requirements Document (PRD) from information below .


=====================================

# Field Mapping Product Requirements Document

## Overview
The Field Mapping PRD defines requirements for mapping PDF form fields from `reports/field-hierarchy.json` into React components within the `app/components/Rendered` and `app/components` directories of the **clarance-f** project. It ensures metadata-driven context keys, dynamic entry management, and accurate UI rendering, using `formHandler.tsx` as the single source of truth and leveraging Redux alongside React Context.

## Core Features

### 1. Field Hierarchy Parsing & Context Mapping
- **What it does:** Parses `field-hierarchy.json` to extract field metadata (id, label, value, type, section) and updates corresponding context keys in `updatedModel.tsx`.
- **Why it’s important:** Automates precise mapping between PDF field IDs and React context keys, minimizes manual errors, and maintains runtime consistency.
- **How it works:** Processes JSON entries, strips/adds the `0 R` suffix at runtime, and populates section-specific context objects via TypeScript interfaces.

### 2. Dynamic Entry Management
- **What it does:** Enables users to add or remove repeatable fields (e.g., **otherNames** in Section 5) through `FormEntryManager.tsx`.
- **Why it’s important:** Prevents rendering unused context entries, aligns the form UI with user interactions, and preserves data integrity.
- **How it works:** Dispatches context updates via `formHandler.tsx`, inserting or removing entries while preserving the original key structure required by the rendering components.

### 3. Component Rendering Support
- **What it does:** Ensures each `Render[SectionName]Info.tsx` component supports all mapped fields defined in JSON.
- **Why it’s important:** Guarantees complete coverage of form requirements for every section, preventing missing fields or misbindings.
- **How it works:** Validates component props against the updated context and TypeScript interfaces, injecting accurate IDs and values.

### 4. Validation & Testing
- **What it does:** Verifies input bindings, dynamic entry flows, and ID alignment against `formHandler.tsx` as the definitive source of truth.
- **Why it’s important:** Ensures the form behaves exactly as specified, safeguarding against data loss or misalignment on submission.
- **How it works:** Executes automated and manual tests in the Windows development environment, covering add/remove flows, context updates, and PDF mapping accuracy.

## User Experience

- **User Persona:** A user completing SF‑86–style forms via a web wizard, requiring clear, dynamic fields aligned with official PDF specifications.
- **Key User Flows:**
  1. Navigate to a section and view default entry fields.
  2. Click **Add Entry** for repeatable sections; new fields appear with correct labels and IDs.
  3. Click **Remove Entry** to delete unwanted fields; context updates and the UI re‑renders accordingly.
  4. Submit the form; values match PDF context keys and are sent via Redux/Context to the backend.
- **UI/UX Considerations:**
  - Dynamic field labels reflect real-time context metadata.
  - **Add/Remove** controls are intuitive and maintain layout consistency.
  - Provide validation feedback for missing required entries or ID mismatches.

## Technical Architecture

- **System Components:**
  - `reports/field-hierarchy.json`
  - `app/utils/formHandler.tsx` and `app/utils/forms/FormEntryManager.tsx`
  - Context modules: `app/state/contexts/updatedModel.tsx` and `app/state/contexts/sections/*`
  - React components: `app/components/Rendered/*` and `app/components/*`
  - TypeScript interfaces: `api/interfaces/sections/*`
  - Redux store and React Context providers
- **Data Models:**
  - Section context keys (e.g., `PersonalInfo`, `NamesInfo`, `EmploymentInfo`).
  - Field metadata schema: `{ name, id, label, value, type, section, sectionName }`.
  - Arrays for repeatable entries in multi-record sections.
- **APIs & Integrations:**
  - Redux for global form state management.
  - React Context for component-level form state.
  - Runtime JSON parsing of field hierarchy data.
  - PDF generation/submission endpoint consuming context keys.
- **Infrastructure Requirements:**
  - Windows development environment with specified paths.
  - Node.js, React, TypeScript, Redux.
  - Linter and formatter to enforce coding standards.
  - Leverage the existing project environment and dependencies as defined in **package.json**; do not scaffold a new application.
  - Confirm that all configurations align with the React + Node.js setup specified in **package.json**.

## Development Roadmap

1. **Phase 1: Context Key Mapping**
   - Parse `field-hierarchy.json`.
   - Update `updatedModel.tsx` with correct ID suffix injection.
   - Validate mapping for Sections 1–2 and the Continuation Section.
2. **Phase 2: Dynamic Entry Logic**
   - Refactor `FormEntryManager.tsx` and `formHandler.tsx` to support add/remove based on user actions.
   - Ensure context arrays update while preserving original key structure.
3. **Phase 3: Component Rendering Support**
   - Update `Render[Section]Info.tsx` components to iterate over context entries.
   - Inject dynamic IDs and values from context.
4. **Phase 4: Validation & Testing**
   - Conduct manual and automated tests for each section (add/remove flows, ID alignment).
   - Perform end-to-end form submission testing to verify PDF field mapping.
5. **Phase 5: Refinement & Documentation**
   - Optimize performance and error handling.
   - Document mapping process, context structures, and developer guidelines.

## Extension: Schema Interface Generation

To streamline interface maintenance, derive TypeScript schemas from `enhanced-pdf-validation.ts` outputs:

1. **Leverage `field-sections.json` & `field-labels.json`**
   - Provides grouping by page and section, raw field names (e.g., `form1[0].Sections17[0].TextField39[0]`), and human-readable labels.
   - Use confidence scores to prioritize required fields.
2. **Generate Section Interfaces Script**
   Create `scripts/generate-section-interfaces.ts`:
```ts
import fs from 'fs';
import path from 'path';

const sectionData = JSON.parse(fs.readFileSync('reports/field-sections.json', 'utf-8'));
const labels = JSON.parse(fs.readFileSync('reports/field-labels.json', 'utf-8'));
const outputDir = 'api/interfaces/generated';

if (!fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir, { recursive: true });
}

Object.entries(sectionData).forEach(([fieldName, sectionNumber]) => {
  const label = labels[fieldName] || 'Unknown';
  const sectionKey = `Section${sectionNumber}`;
  const interfacePath = path.join(outputDir, `${sectionKey}.ts`);
  const property = fieldName.split('.').pop()?.replace(/\[0\]/g, '') || 'field';
  const line = `  ${property}?: string; // ${label}
`;

  if (!fs.existsSync(interfacePath)) {
    fs.writeFileSync(interfacePath,
      `export interface ${sectionKey} {
${line}}
`
    );
  } else {
    fs.appendFileSync(interfacePath, line);
  }
});
```
3. **Normalize & Merge**
   - Supplement or draft existing interfaces in `api/interfaces`.
   - Optionally automate merging and deduplication using `ts-morph`.
4. **Enhance with Metadata**
   - Use `field-metadata.json` to mark optional vs. required fields and attach constraints (e.g., `maxLength`).

### Benefits
- Keeps interfaces aligned with the actual PDF structure.
- Facilitates confident scaffolding of form validation logic.
- Bridges raw PDF analysis with application models in a maintainable way.



 I am trying to properly map the fields for each section into its respective component in C:\Users\Jason\Desktop\AI-Coding\clarance-f\app\components\Rendered
C:\Users\Jason\Desktop\AI-Coding\clarance-f\app\components


My currently workflow is:
1. Look at Each page in C:\Users\Jason\Desktop\AI-Coding\clarance-f\reports\field-hierarchy.json

Each page is represented by example "{pagenumber}":{...} Lines 2-748 in field-hierarchy.json


2. Based on the field example:
          {
                "name": "form1[0].Sections1-6[0].TextField11[0]",
                "id": "9449 0 R",
                "label": "Section 1. Full Name. Provide your full name. If you have only initials in your name, provide them and indicate \"Initial only\". If you do not have a middle name, indicate \"No Middle Name\". If you are a \"Jr.,\" \"Sr.,\" etc. enter this under Suffix. Last Name.\r",
                "value": "Sect1FirstName",
                "type": "PDFTextField",
                "section": 1,
                "sectionName": "Full Name",
                "confidence": 0.98
              },

Parse the id and properly update the proper section context with respect to this given metadata. The id will play a huge role as that value is used in the context key to reference each field. Keep in mind the 0 R has been taken off in the context for data redundancy, but it is added back at runtime for correct parsing. 

This field goes to Section 1 First Name, which belong in:
UpdatedModel.tsx -> PersonalInfo.tsx


Once All values have been properly mapped to context key, the Rendered Component needs to support the structure. 

in this case it would be RenderPersonalInfo in C:\Users\Jason\Desktop\AI-Coding\clarance-f\app\components\Rendered

3. Adjust the FormHandler for adding and removing entries, as the section context key will have more values than the user may need in their instance. 

Consider this example, By default the context renders all 4 otherNames in Section 5, because of the section 5 context key in C:\Users\Jason\Desktop\AI-Coding\clarance-f\app\state\contexts\updatedModel.tsx called namesInfo. 

When rendered in namesInfo.tsx the application shows all 4 otherNames, because it is referencing the namesInfo context in C:\Users\Jason\Desktop\AI-Coding\clarance-f\app\state\contexts\sections

Can you see the problem?

I'd like to only render the other name values if the user pressed the add entry button, and propely remove them from the form if the user pressed the remove button...

But the context key must remain as it is used as a guide for the RenderedNamesInfo component. Thislogic needs to be corrected for all the sections. 

4. Validate in 

C:\Users\Jason\Desktop\AI-Coding\clarance-f\app\components\Rendered
C:\Users\Jason\Desktop\AI-Coding\clarance-f\app\components

by testing the inputs and functionality. I should be able to add and remove items, and those items should correlate to the actual form.. so if I add an entry to section 5, the ids for that 2nd entry, but align with the form context, or the values are not being accurately tracked and portrayed. 


The entire parsed form map in located in C:\Users\Jason\Desktop\AI-Coding\clarance-f\app\utils\formHandler.tsx

so you can always reference that as the source of truth. 



Other Information:
I'm not sure if this is relevant at all, but I am using redux for the form state management. I'm using react context to maintain the form context throughout the application.





Resources:

Form Handler
C:\Users\Jason\Desktop\AI-Coding\clarance-f\app\utils\formHandler.tsx

Form Context Key Overview
C:\Users\Jason\Desktop\AI-Coding\clarance-f\app\state\contexts\updatedModel.tsx

Form Context Key the Section
C:\Users\Jason\Desktop\AI-Coding\clarance-f\app\state\contexts\sections

Typescript Interfaces for Each section
C:\Users\Jason\Desktop\AI-Coding\clarance-f\api\interfaces\sections

React Component for each section
C:\Users\Jason\Desktop\AI-Coding\clarance-f\app\components\Rendered
C:\Users\Jason\Desktop\AI-Coding\clarance-f\app\components


DataFlow:
React Component -> React Context -> Form Handler -> Updatedodel.tsx -> section context key.

Problems:
The rendered component may not need all values in the context at a given entry. For example, section 5 defaults to showing all 4 entries, When hasNames which can be referenced from C:\Users\Jason\Desktop\AI-Coding\clarance-f\app\state\contexts\sections in the section 5 form is checked please render at least the first entry for the other Names. Section 5. 




Other Notes:

to achieve the task of propely mapping fled values and rendering them on the frontend BASED ON THE CURRENT PROJECT/ENVIRPMENT ALREADY OPENED.

Take a look at the package json and refer to cntext 7 mcp when needed based no the package version number

Useful references:

    const fileToSectionMapping: Record<string, { id: string, name: string }> = {
      "personalInfo.tsx": { id: "1", name: "Full Name" },
      "birthInfo.tsx": { id: "2", name: "Date of Birth" },
      "placeOfBirth.tsx": { id: "3", name: "Place of Birth" },
      "aknowledgementInfo.tsx": { id: "4", name: "Social Security Number" },
      "namesInfo.tsx": { id: "5", name: "Other Names Used" },
      "physicalAttributes.tsx": { id: "6", name: "Your Identifying Information" },
      "contactInfo.tsx": { id: "7", name: "Your Contact Information" },
      "passportInfo.tsx": { id: "8", name: "U.S. Passport Information" },
      "citizenshipInfo.tsx": { id: "9", name: "Citizenship" },
      "dualCitizenshipInfo.tsx": { id: "10", name: "Dual/Multiple Citizenship & Foreign Passport Info" },
      "residencyInfo.tsx": { id: "11", name: "Where You Have Lived" },
      "schoolInfo.tsx": { id: "12", name: "Where you went to School" },
      "employmentInfo.tsx": { id: "13", name: "Employment Acitivites" },
      "serviceInfo.tsx": { id: "14", name: "Selective Service" },
      "militaryHistoryInfo.tsx": { id: "15", name: "Military History" },
      "peopleThatKnow.tsx": { id: "16", name: "People Who Know You Well" },
      "relationshipInfo.tsx": { id: "17", name: "Maritial/Relationship Status" },
      "relativesInfo.tsx": { id: "18", name: "Relatives" },
      "foreignContacts.tsx": { id: "19", name: "Foreign Contacts" },
      "foreignActivities.tsx": { id: "20", name: "Foreign Business, Activities, Government Contacts" },
      "mentalHealth.tsx": { id: "21", name: "Psycological and Emotional Health" },
      "policeRecord.tsx": { id: "22", name: "Police Record" },
      "drugActivity.tsx": { id: "23", name: "Illegal Use of Drugs and Drug Activity" },
      "alcoholUse.tsx": { id: "24", name: "Use of Alcohol" },
      "investigationsInfo.tsx": { id: "25", name: "Investigations and Clearance" },
      "finances.tsx": { id: "26", name: "Financial Record" },
      "technology.tsx": { id: "27", name: "Use of Information Technology Systems" },
      "civil.tsx": { id: "28", name: "Involvement in Non-Criminal Court Actions" },
      "association.tsx": { id: "29", name: "Association Record" },
      "signature.tsx": { id: "30", name: "Continuation Space" }
    };


Use enhance the script enhance-pdf-validation to identify each section then subsection if it exists and output separate json file for each categorized section. There should be a total of 30 json files output when the task is complete. Consider each section a sub task until the task is complete. Place the files in app/report/sections


Then use each json section as a context reference to help strengthen and update each context key in the /app/state/context/section file. Consider each section a sub task until the task is complete.


Be sure to go through each file in the app/state/context/section folder and ensure all values are accounted for if the report says the section as X fields ensure that section has X fields on the context key , consider a field as the interface with the { value,id,type,label,name } values

update Field to be Field { value,id,type,label,name }


I am using index DB to store the form contaxt data, and i'm using react redux for form controls, and react context to store the pdf form data.

C:\Users\Jason\Desktop\AI-Coding\clarance-f\api\service\dynamicService.ts

====================================================

Reference this sample:

<context>
# Overview  
[Provide a high-level overview of your product here. Explain what problem it solves, who it's for, and why it's valuable.]

# Core Features  
[List and describe the main features of your product. For each feature, include:
- What it does
- Why it's important
- How it works at a high level]

# User Experience  
[Describe the user journey and experience. Include:
- User personas
- Key user flows
- UI/UX considerations]
</context>
<PRD>
# Technical Architecture  
[Outline the technical implementation details:
- System components
- Data models
- APIs and integrations
- Infrastructure requirements]

# Development Roadmap  
[Break down the development process into phases:
- MVP requirements
- Future enhancements
- Do not think about timelines whatsoever -- all that matters is scope and detailing exactly what needs to be build in each phase so it can later be cut up into tasks]

# Logical Dependency Chain
[Define the logical order of development:
- Which features need to be built first (foundation)
- Getting as quickly as possible to something usable/visible front end that works
- Properly pacing and scoping each feature so it is atomic but can also be built upon and improved as development approaches]

# Risks and Mitigations  
[Identify potential risks and how they'll be addressed:
- Technical challenges
- Figuring out the MVP that we can build upon
- Resource constraints]

# Appendix  
[Include any additional information:
- Research findings
- Technical specifications]
</PRD>


