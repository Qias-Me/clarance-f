/**
 * Page Categorization Bridge Module
 *
 * This module enhances test-pdf-form-task3.ts with improved page-based
 * field categorization from PDF-Page-data.ts.
 *
 * It loads page mapping information generated by enhanced-pdf-validation.ts
 * and provides functions to apply this data to the categorization logic.
 */

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import { dirname } from "path";

// Get the current directory
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Define more accurate section page ranges based on validation
export const refinedSectionPageRanges: Record<number, [number, number]> = {
  1: [5, 5], // Full Name (1 page)
  2: [5, 5], // Date of Birth (1 page)
  3: [5, 5], // Place of Birth (1 page)
  4: [5, 5], // Social Security Number (1 page)
  5: [5, 5], // Other Names Used (1 page)
  6: [5, 5], // Your Identifying Information (1 page)
  7: [6, 6], // Your Contact Information (1 page)
  8: [6, 6], // U.S. Passport Information (1 page)
  9: [6, 7], // Citizenship (2 pages)
  10: [8, 9], // Dual/Multiple Citizenship & Foreign Passport Info (2 pages)
  11: [10, 13], // Where You Have Lived (4 pages)
  12: [14, 16], // Where you went to School (3 pages)
  13: [17, 33], // Employment Activities (17 pages)
  14: [34, 34], // Selective Service (1 page)
  15: [34, 37], // Military History (4 pages)
  16: [38, 38], // People Who Know You Well (1 page)
  17: [39, 44], // Marital/Relationship Status (6 pages)
  18: [45, 62], // Relatives (18 pages)
  19: [63, 66], // Foreign Contacts (4 pages)
  20: [67, 87], // Foreign Business, Activities, Government Contacts (21 pages)
  21: [88, 97], // Psychological and Emotional Health (10 pages)
  22: [98, 104], // Police Record (7 pages)
  23: [105, 111], // Illegal Use of Drugs and Drug Activity (7 pages)
  24: [112, 115], // Use of Alcohol (4 pages)
  25: [116, 117], // Investigations and Clearance (2 pages)
  26: [118, 124], // Financial Record (7 pages)
  27: [125, 126], // Use of Information Technology Systems (2 pages)
  28: [127, 127], // Involvement in Non-Criminal Court Actions (1 page)
  29: [128, 132], // Association Record (5 pages)
  30: [133, 136], // Continuation Space (4 pages)
};

// Define section name prefixes to help with categorization
const sectionNamePrefixes: Record<number, string[]> = {
  1: [
    "Section 1",
    "Full Name",
    "form1[0].Sections1-6[0].TextField11",
    "Sections1-6[0]",
  ],
  2: ["Section 2", "From_Datefield_Name_2[0]", "Sections1-6[0]"],
  3: [
    "Section 3",
    "Place of Birth",
    "Birth City",
    "Birth County",
    "Sections1-6[0]",
  ],
  4: ["Section 4", "Social Security Number", "Sections1-6[0]"],
  5: ["Section 5", "Other Names Used", "section5", "Sections1-6[0]"],
  6: [
    "Section 6",
    "Your Identifying Information",
    "your home address",
    "Sections1-6[0]",
  ],
  7: ["Section 7", "Your Contact Information", "Sections7-9[0]"],
  8: [
    "Section 8",
    "U.S. Passport Information",
    "PassportNumber",
    "Sections7-9[0]",
  ],
  9: [
    "Section 9",
    "Citizenship",
    "Citizenship",
    "Section9",
    "Section9\\.1-9\\",
  ],
  10: [
    "Section 10",
    "Dual/Multiple Citizenship & Foreign Passport Info",
    "DualCitizenship",
    "Section10",
    "Section10\\.1-10\\",
    "Section10-2",
  ],
  11: [
    "Section 11",
    "Where You Have Lived",
    "AlienRegistrationNumber",
    "section11",
    "Section11",
  ],
  12: ["Section 12", "Where you went to School", "Education", "section12"],
  13: [
    "Section 13",
    "Employment Activities",
    "EmploymentActivities",
    "section13",
    "section_13",
  ],
  14: ["Section 14", "Selective Service", "SelectiveService", "Section14"],
  15: ["Section 15", "Military History", "MilitaryHistory", "Section15"],
  16: ["Section 16", "People Who Know You Well", "Section16"],
  17: [
    "Section 17",
    "Maritial/Relationship Status",
    "Relationship",
    "Section17",
  ],
  18: ["Section 18", "Relatives", "Relatives", "Section18"],
  19: ["Section 19", "Foreign Contacts", "ForeignContacts", "Section19"],
  20: [
    "Section 20",
    "Foreign Business, Activities, Government Contacts",
    "ForeignBusiness",
    "ForeignActivities",
    "Section20",
  ],
  21: [
    "Section 21",
    "Psycological and Emotional Health",
    "MentalHealth",
    "Section21",
  ],
  22: ["Section 22", "Police Record", "PoliceRecord", "police", "Section22"],
  23: ["Section 23", "Use of Alcohol", "DrugsUse", "Section23", "Section_23"],
  24: ["Section 24", "Alcohol", "Alcohol", "Section24"],
  25: ["Section 25", "Investigative History", "Clearance", "Section25"],
  26: ["Section 26", "Financial Record", "FinancialRecord", "Section26"],
  27: [
    "Section 27",
    "Use of Information Technology Systems",
    "Technology",
    "Section27",
  ],
  28: ["Section 28", "Civil Court Record", "CivilCourtRecord", "Section28"],
  29: ["Section 29", "Association", "Section29"],
  30: ["Continuation", "continuation"],
};

// Field name patterns that identify specific sections
export const sectionFieldPatterns: Record<number, RegExp[]> = {
  1: [
    /form1\[0\]\.Sections1-6\[0\]\.TextField11\[0\]/i, // Last name
    /form1\[0\]\.Sections1-6\[0\]\.TextField11\[1\]/i, // First name
    /form1\[0\]\.Sections1-6\[0\]\.TextField11\[2\]/i, // Middle name
    /form1\[0\]\.Sections1-6\[0\]\.suffix\[0\]/i, // Name suffix
  ],
  2: [
    /form1\[0\]\.Sections1-6\[0\]\.From_Datefield_Name_2\[0\]/i, // Date of Birth field
    /form1\[0\]\.Sections1-6\[0\]\.#field\[18\]/i, // Second DOB field
  ],
  3: [
    /Section 3/,
    /Place of Birth/,
    /BirthCity/,
    /County/,
    /form1\[0\]\.Sections1-6\[0\]\.TextField11\[3\]/i, // Birth city
    /form1\[0\]\.Sections1-6\[0\]\.TextField11\[4\]/i, // Birth county
    /form1\[0\]\.Sections1-6\[0\]\.School6_State\[0\]/i, // Birth state
    /form1\[0\]\.Sections1-6\[0\]\.DropDownList1\[0\]/i,
  ],
  4: [
    /Section 4/,
    /Social Security Number/,
    /^form1\[0\]\.Sections1-6\[0\]\.SSN/,
    /^SSN\[/,
    /form1\[0\]\.Sections1-6\[0\]\.SSN\[0\]/i, // Primary SSN field
    /form1\[0\]\.Sections1-6\[0\]\.SSN\[1\]/i, // Secondary SSN field
    /SSN\[\d+\]/i,
    /form1\[0\]\.Sections1-6\[0\]\.CheckBox1\[0\]/i,
    /form1\[0\]\.Sections1-6\[0\]\.RadioButtonList\[0\]/i
  ],
  5: [/form1\[0\]\.Sections1-6\[0\]\.section5\[0\]/],
  6: [
    // STRICT: Only these 6 specific fields should be in section 6
    /form1\[0\]\.Sections1-6\[0\]\.DropDownList7\[0\]/i, // Height in inches
    /form1\[0\]\.Sections1-6\[0\]\.DropDownList8\[0\]/i, // Height in feets
    /form1\[0\]\.Sections1-6\[0\]\.DropDownList9\[0\]/i, // Eye color
    /form1\[0\]\.Sections1-6\[0\]\.DropDownList10\[0\]/i, // Hair color
    /form1\[0\]\.Sections1-6\[0\]\.p3-rb3b\[0\]/i, // Sex Male or Female
    /form1\[0\]\.Sections1-6\[0\]\.TextField11\[5\]/i, // Wieght in pounds
  ],
  7: [
    /form1\[0\]\.Sections7-9\[0\]\.TextField11\[1[3-7]\]/i, // Email addresses and extensions
    /form1\[0\]\.Sections7-9\[0\]\.p3-t68\[(1|2|3)\]/i, // Telephone numbers
    /form1\[0\]\.Sections7-9\[0\]\.#field\[(3[3-5]|38|39|40|4[3-5])\]/i, // International numbers, Day/Night indicators
  ],

  8: [
    /Section 8/,
    /U\.S\. Passport Information/,
    /PassportNumber/,
    /form1\[0\]\.Sections7-9\[0\]\.RadioButtonList\[0\]/i,
    /form1\[0\]\.Sections7-9\[0\]\.p3-t68\[0\]/i,
    /form1\[0\]\.Sections7-9\[0\]\.#area\[0\]\.From_Datefield_Name_2\[0\]/i,
    /form1\[0\]\.Sections7-9\[0\]\.#area\[0\]\.To_Datefield_Name_2\[0\]/i,
    /form1\[0\]\.Sections7-9\[0\]\.#area\[0\]\.#field\[4\]/i,
    /form1\[0\]\.Sections7-9\[0\]\.TextField11\[0\]/i,
    /form1\[0\]\.Sections7-9\[0\]\.TextField11\[1\]/i,
    /form1\[0\]\.Sections7-9\[0\]\.TextField11\[2\]/i,
    /form1\[0\]\.Sections7-9\[0\]\.suffix\[0\]/i,
    /form1\[0\]\.Sections7-9\[0\]\.#field\[23\]/i,
    /.*sect8.*/i
  ],
  9: [
    /Section 9/,
    /Citizenship/,
    /Section9\\\.1-9\\\.4/,
    /^form1\[0\]\.Section9/,
    /form1\[0\]\.Sections7-9\[0\]\.RadioButtonList\[(1|2|3)\]/i, // RadioButtonList controls
    /form1\[0\]\.Sections7-9\[0\]\.TextField11\[(3|4|5|6|7|8|9|10|11|12|18)\]/i, // Text fields
    /form1\[0\]\.Sections7-9\[0\]\.DropDownList12\[0\]/i, // Country
    /form1\[0\]\.Sections7-9\[0\]\.School6_State\[0\]/i, // State
    /form1\[0\]\.Sections7-9\[0\]\.suffix\[(1|2)\]/i, // Suffixes
    /form1\[0\]\.Sections7-9\[0\]\.SSN\[0\]/i, // Social Security Number
    /form1\[0\]\.Sections7-9\[0\]\.#field\[(23|25|28)\]/i, // Estimate fields
    /form1\[0\]\.Sections7-9\[0\]\.From_Datefield_Name_2\[(1|2)\]/i, // Date fields
    /.*sect9.*/i, // Any field containing sect9
    /.*9\.1.*/i, // Any field containing 9.1
  ],
  10: [
    /Section 10/,
    /Dual\/Multiple Citizenship & Foreign Passport Info/,
    /Section10\\\.1-10\\\.2/,
    /^form1\[0\]\.Section10/,
  ],
  11: [
    /Section 11/,
    /Where You Have Lived/,
    /Section11/,
    /^form1\[0\]\.Section11/,
  ],
  12: [
    /Section 12/,
    /Where you went to School/,
    /section_12/,
    /^form1\[0\]\.section_12/,
  ],
  13: [
    /Section 13/,
    /Employment Acitivites/,
    /section13/,
    /^form1\[0\]\.section13/,
  ],
  14: [
    /Section 14/,
    /Selective Service/,
    /section14/,
    /^form1\[0\]\.section14/,
  ],
  15: [/Section 15/, /Military History/, /section15/, /^form1\[0\]\.section15/],
  16: [
    /Section 16/,
    /People Who Know You Well/,
    /section16/,
    /Section16/,
    /^form1\[0\]\.Section16/,
  ],
  17: [
    /Section 17/,
    /Maritial\/Relationship Status/,
    /Section17/,
    /^form1\[0\]\.Section17/,
  ],
  18: [/Section 18/, /Relatives/, /Section18/, /^form1\[0\]\.Section18/],
  19: [/Section 19/, /Foreign Contacts/, /Section19/, /^form1\[0\]\.Section19/],
  20: [
    /Section 20/,
    /Foreign Business, Activities, Government Contacts/,
    /Section20/,
    /^form1\[0\]\.Section20/,
  ],
  21: [
    /Section 21/,
    /Psycological and Emotional Health/,
    /Section21/,
    /^form1\[0\]\.Section21/,
  ],
  22: [/Section 22/, /Police Record/, /Section22/, /^form1\[0\]\.Section22/],
  23: [
    /Section 23/,
    /Illegal Use of Drugs and Drug Activity/,
    /Section23/,
    /Section_23/,
    /^form1\[0\]\.Section23/,
    /^form1\[0\]\.Section_23/,
  ],
  24: [/Section 24/, /Use of Alcohol /, /Section24/, /^form1\[0\]\.Section24/],
  25: [
    /Section25/,
    /Investigations and Clearance/,
    /Section25/,
    /^form1\[0\]\.Section25/,
    /^form1\[0\]\.Section_25/,
  ],
  26: [/Section 26/, /Financial Record/, /Section26/, /^form1\[0\]\.Section26/],
  27: [
    /Section 27/,
    /Use of Information Technology Systems/,
    /Section27/,
    /^form1\[0\]\.Section27/,
  ],
  28: [
    /Section 28/,
    /Involvement in Non-Criminal Court Action/,
    /Section28/,
    /^form1\[0\]\.Section28/,
  ],
  29: [
    /Section 29/,
    /Association Record/,
    /Section29/,
    /^form1\[0\]\.Section29/,
  ],
  30: [
    /continuation/,
    /Continuation Space/,
    /^form1\[0\]\.continuation/,
    /^form1\[0\]\..*[cC]ont(?:inue|inuation|d)/,
    /Appendix/,
    /Additional/,
  ],
};

// Complex field name patterns that identify sections, subsections, entries, and sub-entries
const complexFieldPatterns = [
  // Section specific patterns
  {
    regex: /Section(\d+)_(\d+)(?:_(\d+))?/,
    getSectionInfo: (match: RegExpMatchArray) => ({
      section: parseInt(match[1]),
      subsection: match[2],
      entry: match[3] ? parseInt(match[3]) : undefined,
    }),
  },
  {
    regex: /Section(\d+)-(\d+)/,
    getSectionInfo: (match: RegExpMatchArray) => ({
      section: parseInt(match[1]),
      entry: parseInt(match[2]),
    }),
  },
  {
    regex: /Section(\d+)\\\\.(\d+)-\d+\\\\.(\d+)/,
    getSectionInfo: (match: RegExpMatchArray) => ({
      section: parseInt(match[1]),
      subsection: match[2] + "." + match[3],
    }),
  },
  {
    regex: /section(\d+)_(\d+)-(\d+)/,
    getSectionInfo: (match: RegExpMatchArray) => ({
      section: parseInt(match[1]),
      subsection: match[2] + "-" + match[3],
    }),
  },
  {
    regex: /section(\d+)_(\d+)/,
    getSectionInfo: (match: RegExpMatchArray) => ({
      section: parseInt(match[1]),
      subsection: match[2],
    }),
  },
  {
    regex: /Section_(\d+)_(\d+)/,
    getSectionInfo: (match: RegExpMatchArray) => ({
      section: parseInt(match[1]),
      subsection: match[2],
    }),
  },
  // Table and row patterns
  {
    regex: /Table(\d+)\[.*\]\.Row(\d+)/,
    getSectionInfo: (match: RegExpMatchArray) => ({
      // Section needs to be determined from context
      entry: parseInt(match[2]),
    }),
  },
  // Subform patterns
  {
    regex: /#subform\[(\d+)\]\.#area\[(\d+)\]/,
    getSectionInfo: (match: RegExpMatchArray) => ({
      // These typically refer to specific page layouts
      // Section needs to be determined from context
    }),
  },
];

// Field-to-page mapping cache
let fieldPageMapping: Record<string, number> | null = null;
// Section statistics cache
let sectionStats: any = null;

/**
 * Load field page mapping data if it exists
 */
export function loadFieldPageMapping(): Record<string, number> {
  if (fieldPageMapping !== null) {
    return fieldPageMapping;
  }

  try {
    const pageMapPath = path.join(
      __dirname,
      "../reports/field-page-mapping.json"
    );

    if (fs.existsSync(pageMapPath)) {
      const data = JSON.parse(fs.readFileSync(pageMapPath, "utf-8"));
      fieldPageMapping = data;
      console.log(`Loaded page mapping for ${Object.keys(data).length} fields`);
      return data;
    } else {
      console.warn(
        "Field page mapping file not found. Run enhanced-pdf-validation.ts first."
      );
      return {};
    }
  } catch (error) {
    console.error("Error loading field page mapping:", error);
    return {};
  }
}

/**
 * Load section statistics data if it exists
 */
export function loadSectionStats(): any {
  if (sectionStats !== null) {
    return sectionStats;
  }

  try {
    const statsPath = path.join(
      __dirname,
      "../reports/section-page-stats.json"
    );

    if (fs.existsSync(statsPath)) {
      const data = JSON.parse(fs.readFileSync(statsPath, "utf-8"));
      sectionStats = data;
      console.log(
        `Loaded section statistics with ${
          data.sectionStats?.length || 0
        } section entries`
      );
      return data;
    } else {
      console.warn(
        "Section statistics file not found. Run enhanced-pdf-validation.ts first."
      );
      return {};
    }
  } catch (error) {
    console.error("Error loading section statistics:", error);
    return {};
  }
}

/**
 * Get page number for a field from the loaded mapping
 */
export function getFieldPage(fieldName: string): number {
  if (!fieldPageMapping) {
    loadFieldPageMapping();
  }

  return fieldPageMapping?.[fieldName] || 0;
}

/**
 * Extract section info from complex field name patterns
 */
export function extractSectionInfoFromName(fieldName: string): {
  section?: number;
  subsection?: string;
  entry?: number;
  subEntry?: number;
  confidence: number;
} | null {
  if (!fieldName) return null;

  // For debugging
  // console.log(`Analyzing field name: ${fieldName}`);

  // CRITICAL: Strict matching for Section 1 - Only these 4 specific fields should be in Section 1
  const section1Patterns = [
    /form1\[0\]\.Sections1-6\[0\]\.TextField11\[0\]/i, // Last name
    /form1\[0\]\.Sections1-6\[0\]\.TextField11\[1\]/i, // First name
    /form1\[0\]\.Sections1-6\[0\]\.TextField11\[2\]/i, // Middle name
    /form1\[0\]\.Sections1-6\[0\]\.suffix\[0\]/i, // Name suffix
  ];

  for (let i = 0; i < section1Patterns.length; i++) {
    if (section1Patterns[i].test(fieldName)) {
      return {
        section: 1,
        entry: 0, // Base entry content (not repetitive)
        confidence: 0.99
      };
    }
  }

  // Complex multidimensional pattern matching - Example: sect13A.1Entry2StartDate
  // This pattern includes section, subsection, and entry in a complex format
  const complexPatterns = [
    // Pattern: sect13A.1Entry2StartDate -> section 13, subsection A.1, entry 2
    /sect(\d+)([A-Za-z])\.?(\d*)Entry(\d+)/i,

    // Pattern: section13A.1_entry2_startDate -> section 13, subsection A.1, entry 2
    /section(\d+)([A-Za-z])\.?(\d*)[_\s]?entry(\d+)/i,

    // Pattern: section13A.1_instance2_date -> section 13, subsection A.1, entry 2
    /section(\d+)([A-Za-z])\.?(\d*)[_\s]?instance(\d+)/i,

    // Pattern: sect13_subsecA_entry2 -> section 13, subsection A, entry 2
    /sect(\d+)[_\s]?subsec([A-Za-z])[_\s]?entry(\d+)/i,

    // Pattern: section13_subA1_entry2 -> section 13, subsection A1, entry 2
    /section(\d+)[_\s]?sub([A-Za-z]\d*)[_\s]?entry(\d+)/i
  ];

  for (const pattern of complexPatterns) {
    const match = fieldName.match(pattern);
    if (match) {
      const section = parseInt(match[1]);
      const subsectionLetter = match[2].toUpperCase();

      // Handle different pattern variations
      let subsectionNumber = "";
      let entry = 0;

      if (pattern.source.includes("subsec") || pattern.source.includes("sub")) {
        // For patterns like sect13_subsecA_entry2 or section13_subA1_entry2
        subsectionNumber = match[3] && match[3] !== "" ? match[3] : "";
        entry = parseInt(match[3]);
      } else {
        // For patterns like sect13A.1Entry2StartDate
        subsectionNumber = match[3] && match[3] !== "" ? match[3] : "";
        entry = parseInt(match[4]);
      }

      // Combine subsection letter and number if both exist
      const subsection = subsectionNumber ? `${subsectionLetter}.${subsectionNumber}` : subsectionLetter;

      return {
        section,
        subsection,
        entry, // Keep this as entry 1+ for repetitive instances
        confidence: 0.97, // High confidence for complex pattern match
      };
    }
  }

  // Section with explicit subsection and entry patterns (examples from section 21, 17, 16)
  // Pattern: Section21D1, section21d3, Section21a2 - section, subsection, entry
  const explicitSubsectionEntryPattern = /section(\d+)([a-z])(\d*)/i;
  const explicitSubsectionEntryMatch = fieldName.match(explicitSubsectionEntryPattern);
  if (explicitSubsectionEntryMatch) {
    const section = parseInt(explicitSubsectionEntryMatch[1]);
    const subsection = explicitSubsectionEntryMatch[2].toUpperCase();
    let entry = 0; // Default to 0 (base content) if not specified

    if (explicitSubsectionEntryMatch[3]) {
      entry = parseInt(explicitSubsectionEntryMatch[3]); // Keep this as entry 1+ for repetitive instances
    }

    return {
      section,
      subsection,
      entry,
      confidence: 0.95,
    };
  }

  // Pattern: section_21_2 (section 21, entry 2)
  const sectionEntryPattern = /section[_\s]?(\d+)[_\s]?(\d+)/i;
  const sectionEntryMatch = fieldName.match(sectionEntryPattern);
  if (sectionEntryMatch) {
    const section = parseInt(sectionEntryMatch[1]);
    const entry = parseInt(sectionEntryMatch[2]);

    return {
      section,
      entry, // Keep this as entry 1+ for repetitive instances
      confidence: 0.95,
    };
  }

  // Pattern: Section17_1_2 (section 17, subsection 1, entry 2)
  const sectionSubEntryPattern = /section(\d+)_(\d+)_(\d+)/i;
  const sectionSubEntryMatch = fieldName.match(sectionSubEntryPattern);
  if (sectionSubEntryMatch) {
    const section = parseInt(sectionSubEntryMatch[1]);
    const subsection = sectionSubEntryMatch[2];
    const entry = parseInt(sectionSubEntryMatch[3]);

    return {
      section,
      subsection,
      entry, // Keep this as entry 1+ for repetitive instances
      confidence: 0.95,
    };
  }

  // Pattern: Section17_1 (section 17, subsection 1, entry 1)
  const sectionSubPattern = /section(\d+)_(\d+)(?![_\d])/i;
  const sectionSubMatch = fieldName.match(sectionSubPattern);
  if (sectionSubMatch) {
    const section = parseInt(sectionSubMatch[1]);
    const subsection = sectionSubMatch[2];

    return {
      section,
      subsection,
      entry: 1, // Keep entry as 1 for first repetitive instance
      confidence: 0.9,
    };
  }

  // Pattern for camelCase field names with embedded section/subsection/entry
  // Example: section13aEntry2Date or section13SubAEntry2StartDate
  const camelCasePattern = /section(\d+)(?:Sub)?([A-Za-z])(?:Entry|Instance)?(\d+)/i;
  const camelCaseMatch = fieldName.match(camelCasePattern);
  if (camelCaseMatch) {
    const section = parseInt(camelCaseMatch[1]);
    const subsection = camelCaseMatch[2].toUpperCase();
    const entry = parseInt(camelCaseMatch[3]);

    return {
      section,
      subsection,
      entry,
      confidence: 0.92
    };
  }

  // Pattern: form1[0].Sections7-9[0].TextField11[17] -> Section 7 Entry 3
  // Special handling for Section 7 repeating fields
  const section7Pattern = /sections7-9.*?TextField11\[(\d+)]/i;
  const section7Match = fieldName.match(section7Pattern);
  if (section7Match) {
    const textFieldIndex = parseInt(section7Match[1]);

    // Determine entry based on TextField11 index in section 7
    // This is a heuristic based on the given examples
    let entry = 0; // Default to 0 (base content)
    if (textFieldIndex >= 15 && textFieldIndex <= 17) {
      entry = 3; // 3rd repetitive instance
    } else if (textFieldIndex >= 10 && textFieldIndex < 15) {
      entry = 2; // 2nd repetitive instance
    } else if (textFieldIndex < 10) {
      entry = 1; // 1st repetitive instance
    }

    return {
      section: 7,
      entry,
      confidence: 0.9,
    };
  }

  // Special handler for Section 12 table structures
  // Pattern: form1[0].section_12_2[0].Table1[0].Row1[0].Cell1[0]
  const section12TablePattern = /section_12_(\d+).*?Table(\d+)\[.*?Row(\d+)/i;
  const section12TableMatch = fieldName.match(section12TablePattern);
  if (section12TableMatch) {
    const entry = parseInt(section12TableMatch[1]);
    const tableNum = parseInt(section12TableMatch[2]);
    const rowNum = parseInt(section12TableMatch[3]);

    return {
      section: 12,
      entry, // Keep entry 1+ for repetitive instances
      subEntry: (tableNum * 100) + rowNum, // Combine table and row for unique subEntry
      confidence: 0.95,
    };
  }

  // Sections 1-6 pattern with entries
  const sections1To6Pattern = /Sections1-6\[0\]\.TextField11\[(\d+)\]/i;
  const sections1To6Match = fieldName.match(sections1To6Pattern);
  if (sections1To6Match) {
    const textFieldIndex = parseInt(sections1To6Match[1]);

    // Map TextField11 indices to appropriate sections
    // This mapping is based on the strict patterns in rule-loader.ts
    if (textFieldIndex <= 2) {
      // First 3 indices (0, 1, 2) go to Section 1 (first name, last name, middle name)
      return {
        section: 1,
        entry: 0, // Updated to entry 0 as base content
        confidence: 0.95,
      };
    } else if (textFieldIndex >= 3 && textFieldIndex <= 4) {
      // Indices 3, 4 go to Section 3 (birth city, birth county)
      return {
        section: 3,
        entry: 0, // Updated to entry 0 as base content
        confidence: 0.95,
      };
    } else if (textFieldIndex === 5) {
      // Index 5 goes to Section 6 (weight in pounds)
      return {
        section: 6,
        entry: 0, // Updated to entry 0 as base content
        confidence: 0.95,
      };
    }
  }

  // Additional pattern matching for Sections 1-8 (base content)
  // These low-numbered sections don't have subsections but do have entries
  if (fieldName.match(/section[_\s]?([1-8])\b/i)) {
    const sectionMatch = fieldName.match(/section[_\s]?([1-8])\b/i);
    if (sectionMatch) {
      const section = parseInt(sectionMatch[1]);

      // Look for any entry indicators (assume 0 if none found)
      const entryMatch = fieldName.match(/entry[_\s]?(\d+)/i) ||
                          fieldName.match(/instance[_\s]?(\d+)/i);

      return {
        section,
        entry: entryMatch ? parseInt(entryMatch[1]) : 0, // Default to 0 (base content) if no entry indicator
        confidence: 0.85,
      };
    }
  }

  // Basic section detection pattern (less specific)
  const basicSectionPattern = /section(?:[_\s]?|s)(\d+)/i;
  const basicMatch = fieldName.match(basicSectionPattern);
  if (basicMatch) {
    const section = parseInt(basicMatch[1]);

    return {
      section,
      entry: 0, // Default to 0 (base content) for basic section detection
      confidence: 0.85,
    };
  }

  return null;
}

/**
 * Detect section from field value naming pattern
 */
export function detectSectionFromFieldValue(
  value: string | string[] | boolean | undefined
): {
  section: number;
  sectionName: string;
  subsection?: string;
  entry?: number;
  confidence: number;
} | null {
  if (!value) return null;

  // Convert to string for consistent handling
  const strValue = String(value);

  // Enhanced patterns to detect section and subsection information
  // Pattern 1: sect9.2FieldName (e.g., sect9.2CertificateState)
  const pattern1 = /^sect(\d+)\.(\d+)([A-Z]|[_-])/i;

  // Pattern 2: 9.1FieldName (e.g., 9.1MiddleName)
  const pattern2 = /^(\d+)\.(\d+)([A-Z]|[_-])/i;

  // Pattern 3: sect9.2.1FieldName (e.g., sect9.2.1Value)
  const pattern3 = /^sect(\d+)\.(\d+)\.(\d+)/i;

  // Pattern 4: 9.2.1FieldName (e.g., 9.2.1Value)
  const pattern4 = /^(\d+)\.(\d+)\.(\d+)/i;

  // Pattern 5: DocumentNumber9.1 (subsection at the end)
  const pattern5 = /(\d+)\.(\d+)$/i;

  let match;

  // Try pattern 1 first (most specific with 'sect' prefix)
  if ((match = strValue.match(pattern1))) {
    const section = parseInt(match[1]);
    const subsection = match[2];

    return {
      section,
      sectionName: getSectionNameById(section),
      subsection,
      confidence: 0.95
    };
  }

  // Try pattern 3 (with 'sect' prefix and entry)
  if ((match = strValue.match(pattern3))) {
    const section = parseInt(match[1]);
    const subsection = match[2];
    const entry = parseInt(match[3]);

    return {
      section,
      sectionName: getSectionNameById(section),
      subsection,
      entry,
      confidence: 0.92
    };
  }

  // Try pattern 2 (direct numbers without 'sect')
  if ((match = strValue.match(pattern2))) {
    const section = parseInt(match[1]);
    const subsection = match[2];

    return {
      section,
      sectionName: getSectionNameById(section),
      subsection,
      confidence: 0.90
    };
  }

  // Try pattern 4 (direct numbers with entry)
  if ((match = strValue.match(pattern4))) {
    const section = parseInt(match[1]);
    const subsection = match[2];
    const entry = parseInt(match[3]);

    return {
      section,
      sectionName: getSectionNameById(section),
      subsection,
      entry,
      confidence: 0.88
    };
  }

  // Try pattern 5 (subsection at the end)
  if ((match = strValue.match(pattern5))) {
    const section = parseInt(match[1]);
    const subsection = match[2];

    return {
      section,
      sectionName: getSectionNameById(section),
      subsection,
      confidence: 0.85
    };
  }

  // Original patterns (fallback)
  const sectionPattern = /^sect(\d+)/i;
  const sectionNumberPattern = /^(\d+)[A-Z]/;

  if ((match = strValue.match(sectionPattern))) {
    const section = parseInt(match[1]);
    return {
      section,
      sectionName: getSectionNameById(section),
      confidence: 0.8
    };
  }

  if ((match = strValue.match(sectionNumberPattern))) {
    const section = parseInt(match[1]);
    if (section >= 1 && section <= 30) {
      return {
        section,
        sectionName: getSectionNameById(section),
        confidence: 0.7
      };
    }
  }

  return null;
}

// Helper function to get section name by ID
function getSectionNameById(sectionId: number): string {
  const sectionInfo = sectionClassifications.find(s => s.sectionId === sectionId);
  return sectionInfo ? sectionInfo.name : `Section ${sectionId}`;
}

/**
 * Identify section by field name, label, and page
 * This provides much more precise categorization than page number alone
 */
export function identifySectionByField(
  fieldName: string,
  fieldLabel: string | undefined,
  pageNum: number
): number | null {
  // Direct section identification from field name (highest priority)
  if (fieldName) {
    // Look for explicit section patterns like "Section11" or "Section11-2"
    const sectionMatch = fieldName.match(/Section(\d+)(?:[-_]?\d*)?/i);
    if (sectionMatch && sectionMatch[1]) {
      const sectionNum = parseInt(sectionMatch[1], 10);
      if (sectionNum > 0 && sectionNum <= 30) {
        return sectionNum;
      }
    }

    // Use complex pattern matching
    const sectionInfo = extractSectionInfoFromName(fieldName);
    if (sectionInfo?.section) {
      return sectionInfo.section;
    }

    // Look for section5 pattern specifically
    if (fieldName.includes("section5[0]")) {
      return 5;
    }
  }

  // Direct section identification from label (second priority)
  if (fieldLabel) {
    const labelSectionMatch = fieldLabel.match(/Section\s+(\d+)(?:[.\-_]|$)/i);
    if (labelSectionMatch && labelSectionMatch[1]) {
      const sectionNum = parseInt(labelSectionMatch[1], 10);
      if (sectionNum > 0 && sectionNum <= 30) {
        return sectionNum;
      }
    }
  }
  // Special case for Section 6 - strict matching for the 6 specific fields
  if (
    fieldName &&
    (fieldName === "form1[0].Sections1-6[0].DropDownList7[0]" ||
      fieldName === "form1[0].Sections1-6[0].DropDownList8[0]" ||
      fieldName === "form1[0].Sections1-6[0].DropDownList9[0]" ||
      fieldName === "form1[0].Sections1-6[0].DropDownList10[0]" ||
      fieldName === "form1[0].Sections1-6[0].p3-rb3b[0]" ||
      fieldName === "form1[0].Sections1-6[0].TextField11[5]")
  ) {
    return 6;
  }

  // First check specific field patterns that strongly indicate a section
  for (const [sectionId, patterns] of Object.entries(sectionFieldPatterns)) {
    // Skip section 6 as we've already handled it with exact matching above
    if (sectionId === "6") continue;

    for (const pattern of patterns) {
      if (
        (fieldName && pattern.test(fieldName)) ||
        (fieldLabel && pattern.test(fieldLabel))
      ) {
        return parseInt(sectionId);
      }
    }
  }

  // Check if the field name includes section prefix
  for (const [sectionId, prefixes] of Object.entries(sectionNamePrefixes)) {
    for (const prefix of prefixes) {
      if (
        (fieldName && fieldName.includes(prefix)) ||
        (fieldLabel && fieldLabel.includes(prefix))
      ) {
        return parseInt(sectionId);
      }
    }
  }

  // Special case for Sections1-6 field names
  if (fieldName) {
    if (
      fieldName.includes("Sections1-6[0].TextField11[0]") ||
      fieldName.includes("Sections1-6[0].TextField11[1]") ||
      fieldName.includes("Sections1-6[0].TextField11[2]")
    ) {
      return 1;
    }

    if (fieldName.includes("Sections1-6[0].From_Datefield_Name_2[0]")) {
      return 2;
    }

    if (
      fieldName.includes("Sections1-6[0].TextField11[3]") ||
      fieldName.includes("Sections1-6[0].TextField11[4]") ||
      fieldName.includes("Sections1-6[0].School6_State[0]") ||
      fieldName.includes("Sections1-6[0].DropDownList1[0]")
    ) {
      return 3;
    }
    if (fieldName.includes("Sections1-6[0].SSN[1]")) {
      return 4;
    }

    // Section 6 - Your Identifying Information
    if (
      fieldName.includes("Sections1-6[0].DropDownList7[0]") ||
      fieldName.includes("Sections1-6[0].DropDownList8[0]") ||
      fieldName.includes("Sections1-6[0].DropDownList9[0]") ||
      fieldName.includes("Sections1-6[0].DropDownList10[0]") ||
      fieldName.includes("Sections1-6[0].p3-rb3b[0]") ||
      fieldName.includes("Sections1-6[0].TextField11[5]")
    ) {
      return 6;
    }
  }

  // If no direct match by name/label, try page-based assignment with priority given to
  // section-specific page ranges when overlapping
  for (const [sectionIdStr, [startPage, endPage]] of Object.entries(
    refinedSectionPageRanges
  )) {
    const sectionId = parseInt(sectionIdStr);

    // Exact page match for non-overlapping sections
    if (pageNum >= startPage && pageNum <= endPage) {
      // For overlapping pages, apply section-specific logic
      if (pageNum === 5) {
        // Page 5 has both section 5 and 6
        // Check for section 5 specific patterns in field name
        if (fieldName && fieldName.includes("section5[0]")) {
          return 5;
        }
        // Otherwise default to section 6 for page 5
        return 6;
      }

      return sectionId;
    }
  }

  // Fallback to page-based logic
  return identifySectionByPage(pageNum);
}

/**
 * Identify section primarily by page number (use as fallback)
 */
export function identifySectionByPage(pageNum: number): number | null {
  // Simple page range check
  for (const [sectionIdStr, [startPage, endPage]] of Object.entries(
    refinedSectionPageRanges
  )) {
    const sectionId = parseInt(sectionIdStr);
    if (pageNum >= startPage && pageNum <= endPage) {
      return sectionId;
    }
  }

  return null;
}

/**
 * Enhanced version of identifySectionByPage that includes confidence scores
 * This version provides better accuracy and can be used by other modules
 */
export function identifySectionByPageWithConfidence(
  pageNum: number
): { section: number; confidence: number } | null {
  // Direct matching from our refined page ranges
  for (const [sectionIdStr, [startPage, endPage]] of Object.entries(
    refinedSectionPageRanges
  )) {
    const sectionId = parseInt(sectionIdStr);
    if (pageNum >= startPage && pageNum <= endPage) {
      // Calculate confidence based on range specificity
      // Smaller ranges = higher confidence
      const rangeSize = endPage - startPage + 1;
      const confidence =
        rangeSize === 1 ? 0.95 : 0.9 - Math.min(rangeSize, 10) / 20;

      return {
        section: sectionId,
        confidence: confidence,
      };
    }
  }

  // If no match was found in any range
  return { section: -1, confidence: 0.0 }; // Low confidence fallback
}

/**
 * Enhanced section categorization based on multiple data points
 *
 * This function combines:
 * 1. Page number (highest priority)
 * 2. Keywords in field label (second priority)
 * 3. Path pattern analysis (third priority)
 * 4. Options
 * 5. Field value reference (if not null/empty)
 * 6. Custom rules for continuations and special fields
 */
export function enhancedSectionCategorization(
  fieldName: string,
  fieldLabel: string | undefined,
  pageNum: number,
  fieldValue?: any
): { section: number; confidence: number } | null {
  // Create a results object to track the best match
  let bestMatch: { section: number; confidence: number } | null = null;

  // STEP 1: Parse by page number (highest priority)
  if (pageNum > 0) {
    const pageSectionInfo = identifySectionByPage(pageNum);
    if (pageSectionInfo !== null) {
      bestMatch = { section: pageSectionInfo, confidence: 0.88 }; // Increased base confidence for page-based matches

      // If the page is uniquely associated with one section (not overlapping),
      // we can have higher confidence
      const overlappingPages = Object.entries(refinedSectionPageRanges).filter(
        ([_, [start, end]]) => pageNum >= start && pageNum <= end
      ).length;

      if (overlappingPages === 1) {
        bestMatch.confidence = 0.92; // Higher confidence for non-overlapping pages
      }

      // Check if the page is in the middle of a section's range (not at boundaries)
      // which gives even higher confidence
      const [start, end] = refinedSectionPageRanges[pageSectionInfo] || [0, 0];
      if (pageNum > start && pageNum < end && end - start > 2) {
        bestMatch.confidence = 0.94; // Even higher confidence for middle pages
      }
    }
  }

  // STEP 2: Keywords in field label (second priority)
  if (fieldLabel) {
    // Check for explicit section mentions in label
    const labelSectionMatch = fieldLabel.match(/Section\s+(\d+)(?:[.\-_]|$)/i);
    if (labelSectionMatch && labelSectionMatch[1]) {
      const sectionNum = parseInt(labelSectionMatch[1], 10);
      if (sectionNum > 0 && sectionNum <= 30) {
        const newMatch = { section: sectionNum, confidence: 0.82 };

        // If page number also confirms this section, increase confidence significantly
        if (pageNum > 0) {
          const pageSectionInfo = identifySectionByPage(pageNum);
          if (pageSectionInfo === sectionNum) {
            newMatch.confidence = 0.96; // Very high confidence when page and label match
          }
        }

        // Only replace if this has higher confidence
        if (!bestMatch || newMatch.confidence > bestMatch.confidence) {
          bestMatch = newMatch;
        }
      }
    }

    // Check for continuation-specific keywords in label
    if (fieldLabel.match(/continuation|continued|additional|appendix/i)) {
      const newMatch = { section: 30, confidence: 0.84 };

      // If page number also confirms this is a continuation page, increase confidence
      if (pageNum > 0 && pageNum >= refinedSectionPageRanges[30][0]) {
        newMatch.confidence = 0.94;
      }

      if (!bestMatch || newMatch.confidence > bestMatch.confidence) {
        bestMatch = newMatch;
      }
    }

    // Check for section-specific keywords in label
    for (const [sectionId, prefixes] of Object.entries(sectionNamePrefixes)) {
      for (const prefix of prefixes) {
        if (fieldLabel.includes(prefix)) {
          const sectionNum = parseInt(sectionId);
          const newMatch = { section: sectionNum, confidence: 0.84 };

          // If page number also confirms this section, increase confidence
          if (pageNum > 0) {
            const [start, end] = refinedSectionPageRanges[sectionNum] || [0, 0];
            if (pageNum >= start && pageNum <= end) {
              newMatch.confidence = 0.94; // Higher confidence when page range matches keyword
            }
          }

          // Only replace if this has higher confidence
          if (!bestMatch || newMatch.confidence > bestMatch.confidence) {
            bestMatch = newMatch;
          }
          break;
        }
      }
    }
  }

  // STEP 3: Path pattern analysis (third priority)
  if (fieldName) {
    // Direct section identification from field name patterns
    const sectionMatch = fieldName.match(/Section(\d+)(?:[-_]?\d*)?/i);
    if (sectionMatch && sectionMatch[1]) {
      const sectionNum = parseInt(sectionMatch[1], 10);
      if (sectionNum > 0 && sectionNum <= 30) {
        const newMatch = { section: sectionNum, confidence: 0.86 };

        // If page number also confirms this section, increase confidence
        if (pageNum > 0) {
          const [start, end] = refinedSectionPageRanges[sectionNum] || [0, 0];
          if (pageNum >= start && pageNum <= end) {
            newMatch.confidence = 0.96; // Higher confidence when page range matches pattern
          }
        }

        // Only replace if this has higher confidence
        if (!bestMatch || newMatch.confidence > bestMatch.confidence) {
          bestMatch = newMatch;
        }
      }
    }

    // Check for continuation pages in field name
    if (fieldName.match(/continuation|continued|cont(?:_|\d|\.|$)/i)) {
      const newMatch = { section: 30, confidence: 0.88 };

      // If page number also confirms this is a continuation page, increase confidence
      if (pageNum > 0 && pageNum >= refinedSectionPageRanges[30][0]) {
        newMatch.confidence = 0.96;
      }

      if (!bestMatch || newMatch.confidence > bestMatch.confidence) {
        bestMatch = newMatch;
      }
    }

    // Try complex pattern extraction
    const complexInfo = extractSectionInfoFromName(fieldName);
    if (complexInfo?.section) {
      const newMatch = {
        section: complexInfo.section,
        confidence: complexInfo.confidence,
      };

      // If page number also confirms this section, increase confidence
      if (pageNum > 0) {
        const [start, end] = refinedSectionPageRanges[complexInfo.section] || [
          0, 0,
        ];
        if (pageNum >= start && pageNum <= end) {
          newMatch.confidence = Math.min(newMatch.confidence + 0.1, 0.98); // Boost confidence when page confirms
        } else {
          // If page contradicts the pattern, slightly reduce confidence
          newMatch.confidence = Math.max(newMatch.confidence - 0.05, 0.7);
        }
      }

      // Only replace if this has higher confidence
      if (!bestMatch || newMatch.confidence > bestMatch.confidence) {
        bestMatch = newMatch;
      }
    }

    // Check field name against specific patterns
    for (const [sectionId, patterns] of Object.entries(sectionFieldPatterns)) {
      for (const pattern of patterns) {
        if (pattern.test(fieldName)) {
          const sectionNum = parseInt(sectionId);
          const newMatch = { section: sectionNum, confidence: 0.88 };

          // If page number also confirms this section, increase confidence
          if (pageNum > 0) {
            const [start, end] = refinedSectionPageRanges[sectionNum] || [0, 0];
            if (pageNum >= start && pageNum <= end) {
              newMatch.confidence = 0.96; // Higher confidence when page range matches pattern
            }
          }

          // Only replace if this has higher confidence
          if (!bestMatch || newMatch.confidence > bestMatch.confidence) {
            bestMatch = newMatch;
          }
          break;
        }
      }
    }

    // Check section name prefixes
    for (const [sectionId, prefixes] of Object.entries(sectionNamePrefixes)) {
      for (const prefix of prefixes) {
        if (fieldName.includes(prefix)) {
          const sectionNum = parseInt(sectionId);
          const newMatch = { section: sectionNum, confidence: 0.86 };

          // If page number also confirms this section, increase confidence
          if (pageNum > 0) {
            const [start, end] = refinedSectionPageRanges[sectionNum] || [0, 0];
            if (pageNum >= start && pageNum <= end) {
              newMatch.confidence = 0.94; // Higher confidence when page range matches prefix
            }
          }

          // Only replace if this has higher confidence
          if (!bestMatch || newMatch.confidence > bestMatch.confidence) {
            bestMatch = newMatch;
          }
          break;
        }
      }
    }
    // Special case for Sections1-6 field names
    if (fieldName.includes("Sections1-6")) {
      let newMatch = null;

      if (
        fieldName.includes("TextField11[0]") ||
        fieldName.includes("TextField11[1]") ||
        fieldName.includes("TextField11[2]") ||
        fieldName.includes("suffix[0]")
      ) {
        newMatch = { section: 1, confidence: 0.95 };
      } else if (fieldName.includes("From_Datefield_Name_2[0]")) {
        newMatch = { section: 2, confidence: 0.95 };
      } else if (
        fieldName.includes("TextField11[3]") ||
        fieldName.includes("TextField11[4]") ||
        fieldName.includes("School6_State[0]") ||
        fieldName.includes("DropDownList1[0]")
      ) {
        newMatch = { section: 3, confidence: 0.95 };
      } else if (fieldName.includes("SSN[1]")) {
        newMatch = { section: 4, confidence: 0.95 };
      } else if (
        // STRICT matching for section 6 - only these specific fields belong to Section 6
        fieldName === "form1[0].Sections1-6[0].DropDownList7[0]" ||
        fieldName === "form1[0].Sections1-6[0].DropDownList8[0]" ||
        fieldName === "form1[0].Sections1-6[0].DropDownList9[0]" ||
        fieldName === "form1[0].Sections1-6[0].DropDownList10[0]" ||
        fieldName === "form1[0].Sections1-6[0].p3-rb3b[0]" ||
        fieldName === "form1[0].Sections1-6[0].TextField11[5]"
      ) {
        newMatch = { section: 6, confidence: 0.98 }; // Increased confidence for exact matching
      }

      // Only replace if we found a match and it has higher confidence
      if (
        newMatch &&
        (!bestMatch || newMatch.confidence > bestMatch.confidence)
      ) {
        bestMatch = newMatch;
      }
    }
  }
  // STEP 4: Field value reference (if not null/empty)
  if (fieldValue !== undefined && fieldValue !== null && bestMatch) {
    // Convert the value to a string for pattern matching
    let valueStr = "";

    if (typeof fieldValue === "string") {
      valueStr = fieldValue;
    } else if (typeof fieldValue === "boolean") {
      valueStr = fieldValue ? "Yes" : "No";
    } else if (Array.isArray(fieldValue)) {
      valueStr = fieldValue.join(" ");
    } else {
      valueStr = String(fieldValue);
    }

    // If the field value is not empty
    if (valueStr.trim() !== "") {
      // If the field value contains section-specific content, we can potentially boost confidence
      const valueMatch = valueStr.match(/Section\s+(\d+)/i);
      if (valueMatch && Array.isArray(valueMatch) && valueMatch.length > 1) {
        const valueSectionNum = parseInt(valueMatch[1], 10);
        if (valueSectionNum === bestMatch.section) {
          bestMatch.confidence = Math.min(bestMatch.confidence + 0.02, 0.98);
        } else if (valueSectionNum > 0 && valueSectionNum <= 30) {
          // The value references a different section than our match
          // This might be a continuation field or a cross-reference
          // If the confidence is currently low, consider switching to the referenced section
          if (bestMatch.confidence < 0.8) {
            const newMatch = { section: valueSectionNum, confidence: 0.75 };

            // If page number confirms this section, boost the confidence
            if (pageNum > 0) {
              const [start, end] = refinedSectionPageRanges[
                valueSectionNum
              ] || [0, 0];
              if (pageNum >= start && pageNum <= end) {
                newMatch.confidence = 0.85;
              }
            }

            if (newMatch.confidence > bestMatch.confidence) {
              bestMatch = newMatch;
            }
          }
        }
      }

      // Check for section-specific keywords in the field value
      if (bestMatch) {
        const sectionPrefixes = sectionNamePrefixes[bestMatch.section];
        if (sectionPrefixes) {
          for (const prefix of sectionPrefixes) {
            if (valueStr.toLowerCase().includes(prefix.toLowerCase())) {
              bestMatch.confidence = Math.min(
                bestMatch.confidence + 0.02,
                0.98
              );
              break;
            }
          }
        }
      }

      // For continuation section (30), check for references to other sections
      if (bestMatch && bestMatch.section === 30) {
        // If the field value mentions a specific section, it's a strong indicator for continuation
        const continuationMatch = valueStr.match(
          /continued|continuation|additional info|refer to section|see section/i
        );
        if (continuationMatch) {
          bestMatch.confidence = Math.min(bestMatch.confidence + 0.05, 0.98);
        }
      }
    }
  }

  // STEP 5: Special case handling for ambiguous fields with low confidence
  // If we have a match but low confidence, try analyzing field value more deeply
  if (
    bestMatch &&
    bestMatch.confidence < 0.7 &&
    fieldValue !== undefined &&
    fieldValue !== null
  ) {
    // For fields with substantial content, prioritize page-based identification
    if (pageNum > 0) {
      const pageSectionInfo = identifySectionByPage(pageNum);
      if (pageSectionInfo !== null && pageSectionInfo !== bestMatch.section) {
        // Page-based section contradicts current match, consider switching
        const pageConfidence = 0.78; // Moderate confidence for page-based override of low confidence match
        if (pageConfidence > bestMatch.confidence) {
          bestMatch = { section: pageSectionInfo, confidence: pageConfidence };
        }
      }
    }
  }

  // Final confidence adjustment based on agreement between different identification methods
  if (bestMatch && pageNum > 0) {
    const pageSectionInfo = identifySectionByPage(pageNum);

    // If our best match contradicts the page-based identification and has lower confidence,
    // adjust based on how far the page is from the expected section's page range
    if (
      pageSectionInfo !== null &&
      pageSectionInfo !== bestMatch.section &&
      bestMatch.confidence < 0.9
    ) {
      const [expectedStart, expectedEnd] = refinedSectionPageRanges[
        bestMatch.section
      ] || [0, 0];

      // If the field is far outside its expected page range, reduce confidence
      if (expectedStart > 0 && expectedEnd > 0) {
        if (pageNum < expectedStart - 2 || pageNum > expectedEnd + 2) {
          // Significant deviation from expected pages, reduce confidence
          bestMatch.confidence = Math.max(bestMatch.confidence - 0.1, 0.6);
        } else if (pageNum < expectedStart - 1 || pageNum > expectedEnd + 1) {
          // Minor deviation, reduce confidence slightly
          bestMatch.confidence = Math.max(bestMatch.confidence - 0.05, 0.7);
        }
      }
    }
  }

  return bestMatch;
}

/**
 * Enhanced categorization function that prioritizes page-based identification
 * and also uses field values to improve accuracy
 *
 * This function can be used to replace or enhance the categorizeField function in test-pdf-form-task3.ts
 */
export function enhancedCategorizeField(field: any): {
  sectionId: number;
  subsectionId: string;
  entry?: number;
  subEntry?: number;
  confidence: number;
} | null {
  if (!field || !field.name) return null;

  // Extract all relevant field information
  const fieldName = field.name;
  const fieldLabel = field.label || "";
  const pageNum = getFieldPage(fieldName);
  const fieldValue = field.value || "";

  // Use enhanced categorization with field value
  const sectionInfo = enhancedSectionCategorization(
    fieldName,
    fieldLabel,
    pageNum,
    fieldValue
  );

  if (!sectionInfo) return null;

  // Extract subsection, entry and subEntry information if available
  const detailedInfo = extractSectionInfoFromName(fieldName);

  return {
    sectionId: sectionInfo.section,
    subsectionId: detailedInfo?.subsection || "0",
    entry: detailedInfo?.entry,
    subEntry: detailedInfo?.subEntry,
    confidence: sectionInfo.confidence,
  };
}

// Load field labels from page-summary-report if available
const fieldLabels: Record<string, string> = {};

/**
 * Load field labels from reports if available
 */
export function loadFieldLabels(): Record<string, string> {
  if (Object.keys(fieldLabels).length > 0) {
    return fieldLabels;
  }

  try {
    const labelsPath = path.join(__dirname, "../reports/field-labels.json");

    if (fs.existsSync(labelsPath)) {
      const data = JSON.parse(fs.readFileSync(labelsPath, "utf-8"));
      Object.assign(fieldLabels, data);
      console.log(`Loaded labels for ${Object.keys(data).length} fields`);
    } else {
      console.warn(
        "Field labels file not found. Some categorization confidence may be reduced."
      );
    }
  } catch (error) {
    console.error("Error loading field labels:", error);
  }

  return fieldLabels;
}

// The bridge module should be initialized before use
export function initPageCategorization(): boolean {
  loadFieldPageMapping();
  loadSectionStats();
  loadFieldLabels();

  // Return true if both data sets were loaded successfully
  return !!fieldPageMapping && !!sectionStats;
}

/**
 * Update field page information using the loaded mapping
 */
export function updateFieldWithPageData(field: any): void {
  if (!field || !field.name) return;

  // Skip if field already has page data
  if (field.page && field.page > 0) return;

  // Get page from mapping
  const page = getFieldPage(field.name);
  if (page > 0) {
    field.page = page;
  }
}

/**
 * Create an empty field page mapping if none exists
 * This is used by the section mapper to ensure there's at least a minimal structure
 */
export function createEmptyFieldPageMapping(): Record<string, number> {
  const pageMappingPath = path.join(
    __dirname,
    "../reports/field-page-mapping.json"
  );

  if (!fs.existsSync(pageMappingPath)) {
    console.log("Creating empty field page mapping file");
    fs.writeFileSync(pageMappingPath, JSON.stringify({}, null, 2));
  }

  return {};
}

/**
 * Create an empty section stats file if none exists
 * This is used by the section mapper to ensure there's at least a minimal structure
 */
export function createEmptySectionStats(): any {
  const statsPath = path.join(__dirname, "../reports/section-page-stats.json");

  if (!fs.existsSync(statsPath)) {
    console.log("Creating empty section stats file");
    fs.writeFileSync(
      statsPath,
      JSON.stringify(
        {
          sectionStats: [],
          pageStats: [],
        },
        null,
        2
      )
    );
  }

  return {
    sectionStats: [],
    pageStats: [],
  };
}

/**
 * Get page range for a section
 */
export function getSectionPageRange(sectionId: number): [number, number] {
  return refinedSectionPageRanges[sectionId] || [0, 0];
}

/**
 * Get all fields from a specific section
 */
export function getFieldsForSection(sectionId: number, metadata: any[]): any[] {
  return metadata.filter((field) => {
    const result = enhancedSectionCategorization(
      field.name,
      field.label,
      field.page || 0,
      field.value
    );

    return result && result.section === sectionId;
  });
}

/**
 * Get field pattern from field name
 */
export function getFieldPattern(fieldName: string): string {
  return fieldName.replace(/\[\d+\]/g, "[i]");
}

/**
 * Generate a test dataset if no extracted-metadata.json exists
 * This allows section mapper to still work without the full PDF extraction
 */
export function generateMinimalMetadata(): any[] {
  // Create a minimal set of test data with one field per section
  const minimalData: any[] = [];

  for (let sectionId = 1; sectionId <= 30; sectionId++) {
    // Add a sample field for each section
    const [startPage, endPage] = refinedSectionPageRanges[sectionId] || [0, 0];
    const page = startPage > 0 ? startPage : sectionId; // Use section ID as fallback

    minimalData.push({
      name: `Sample_Section${sectionId}_Field`,
      label: `Section ${sectionId} Field`,
      page: page,
      type: "TextField",
      value: `Sample value for section ${sectionId}`,
    });

    // Add some section-specific fields using the patterns
    if (sectionFieldPatterns[sectionId]) {
      const patterns = sectionFieldPatterns[sectionId];
      if (patterns.length > 0) {
        const pattern = patterns[0].toString();
        const patternField = pattern.replace(/[\/\\^$*+?.()|[\]{}]/g, "");

        minimalData.push({
          name: patternField,
          label: `Section ${sectionId} Pattern Field`,
          page: page,
          type: "TextField",
          value: `Pattern value for section ${sectionId}`,
        });
      }
    }
  }

  return minimalData;
}

// Add section mapping system with multi-dimensional classification

// Define section classification schema
interface SectionClassification {
  sectionId: number;
  name: string;
  pageRanges: [number, number][];
  fieldPathPatterns: RegExp[];
  valueKeywords: string[];
  contextKeys: string[];
  neighborFields: string[];
  confidence: number;
}

// Define comprehensive section classification mappings
// Define comprehensive section classification mappings
export const sectionClassifications: SectionClassification[] = [
  {
    sectionId: 1,
    name: "Full Name",
    pageRanges: [[5, 5]],
    fieldPathPatterns: [
      /Section1/,
      /section1/,
      /FullName/,
      /Name_/,
      /form1\[0\]\.Sections1-6\[0\]\.TextField11\[0\]/,
      /^form1\[0\]\.Sections1-6\[0\]\.TextField11\[1\]/,
      /^form1\[0\]\.Sections1-6\[0\]\.TextField11\[2\]/,
      /^form1\[0\]\.Sections1-6\[0\]\.suffix\[0\]/,
    ],
    valueKeywords: ["sect1", "name", "first", "last", "middle", "suffix"],
    contextKeys: [
      "form1[0].Sections1-6[0].TextField11[0]",
      "form1[0].Sections1-6[0].TextField11[1]",
    ],
    neighborFields: ["suffix", "firstName", "lastName", "middleName"],
    confidence: 0.95,
  },
  {
    sectionId: 2,
    name: "Date of Birth",
    pageRanges: [[5, 5]],
    fieldPathPatterns: [
      /Section2/,
      /section2/,
      /DateOfBirth/,
      /DOB/,
      /From_Datefield_Name_2\[0\]/,
      /^form1\[0\]\.Sections1-6\[0\]\.From_Datefield_Name_2/,
    ],
    valueKeywords: ["sect2", "birth", "date", "dob", "born"],
    contextKeys: ["form1[0].Sections1-6[0].From_Datefield_Name_2[0]"],
    neighborFields: ["birthDate", "birthMonth", "birthDay", "birthYear"],
    confidence: 0.95,
  },
  {
    sectionId: 3,
    name: "Place of Birth",
    pageRanges: [[5, 5]],
    fieldPathPatterns: [
      /Section3/,
      /section3/,
      /PlaceOfBirth/,
      /BirthPlace/,
      /^form1\[0\]\.Sections1-6\[0\]\.TextField11\[3\]/,
      /^form1\[0\]\.Sections1-6\[0\]\.TextField11\[4\]/,
      /^form1\[0\]\.Sections1-6\[0\]\.School6_State\[0\]/,
      /^form1\[0\]\.Sections1-6\[0\]\.DropDownList1\[0\]/,
    ],
    valueKeywords: [
      "sect3",
      "city",
      "county",
      "birth",
      "place",
      "state",
      "country",
    ],
    contextKeys: [
      "form1[0].Sections1-6[0].TextField11[3]",
      "form1[0].Sections1-6[0].TextField11[4]",
    ],
    neighborFields: ["birthCity", "birthCounty", "birthState", "birthCountry"],
    confidence: 0.95,
  },
  {
    sectionId: 4,
    name: "Social Security Number",
    pageRanges: [[5, 5]], // Can appear in many places
    fieldPathPatterns: [
      /Section4/,
      /section4/,
      /SSN/,
      /^form1\[0\]\.Sections1-6\[0\]\.SSN\[1\]/,
      /^form1\[0\]\.Sections1-6\[0\]\.SSN/,
    ],
    valueKeywords: ["sect4", "ssn", "social security", "security number"],
    contextKeys: ["form1[0].Sections1-6[0].SSN[1]"],
    neighborFields: ["ssn", "SSN"],
    confidence: 0.95,
  },
  {
    sectionId: 5,
    name: "Other Names Used",
    pageRanges: [[5, 5]],
    fieldPathPatterns: [
      /Section5/,
      /section5/,
      /OtherNames/,
      /AKA/,
      /^form1\[0\]\.section5\[0\]/,
      /RadioButtonList\[0\]/,
    ],
    valueKeywords: ["sect5", "other names", "maiden", "previous", "alias"],
    contextKeys: [
      "form1[0].section5[0]",
      "form1[0].section5[0].RadioButtonList[0]",
    ],
    neighborFields: ["otherNames", "previousNames", "fromDate", "toDate"],
    confidence: 0.95,
  },
  {
    sectionId: 6,
    name: "Your Identifying Information",
    pageRanges: [[5, 5]],
    fieldPathPatterns: [
      // STRICT: Only these 6 specific fields should be in section 6
      /form1\[0\]\.Sections1-6\[0\]\.DropDownList7\[0\]/i, // Sex
      /form1\[0\]\.Sections1-6\[0\]\.DropDownList8\[0\]/i, // Hair color
      /form1\[0\]\.Sections1-6\[0\]\.DropDownList9\[0\]/i, // Eye color
      /form1\[0\]\.Sections1-6\[0\]\.DropDownList10\[0\]/i, // Height/Weight field
      /form1\[0\]\.Sections1-6\[0\]\.p3-rb3b\[0\]/i, // Special field
      /form1\[0\]\.Sections1-6\[0\]\.TextField11\[5\]/i, // Additional field
    ],
    valueKeywords: ["sect6", "sex", "height", "weight", "hair", "eye"],
    contextKeys: [
      "form1[0].Sections1-6[0].DropDownList7[0]",
      "form1[0].Sections1-6[0].DropDownList8[0]",
    ],
    neighborFields: ["sex", "height", "weight"],
    confidence: 0.9,
  },
  {
    sectionId: 7,
    name: "Your Contact Information",
    pageRanges: [[6, 6]],
    fieldPathPatterns: [
      /Section7/,
      /section7/,
      /ContactInfo/,
      /Contact/,
      /p3-t68\[2\]/,
    ],
    valueKeywords: ["sect7", "phone", "email", "contact", "mobile", "work"],
    contextKeys: ["p3-t68[2]", "#field[39]"],
    neighborFields: ["phoneNumber", "emailAddress", "alternatePhone"],
    confidence: 0.9,
  },
  {
    sectionId: 8,
    name: "U.S. Passport Information",
    pageRanges: [[6, 6]],
    fieldPathPatterns: [/Section8/, /section8/, /Passport/, /PassportNumber/],
    valueKeywords: ["sect8", "passport", "issue", "expiration"],
    contextKeys: [],
    neighborFields: [
      "passportNumber",
      "passportIssueDate",
      "passportExpirationDate",
    ],
    confidence: 0.9,
  },
  {
    sectionId: 9,
    name: "Citizenship",
    pageRanges: [[6, 7]],
    fieldPathPatterns: [
      /Section9/,
      /section9/,
      /Citizenship/,
      /Section9\\\.1-9\\\.4/,
      /^form1\[0\]\.Section9/,
    ],
    valueKeywords: [
      "sect9",
      "citizen",
      "citizenship",
      "birth",
      "naturalization",
    ],
    contextKeys: ["form1[0].Section9", "form1[0].Section9.1-9.4"],
    neighborFields: [
      "citizenshipStatus",
      "citizenshipType",
      "citizenshipCertificate",
    ],
    confidence: 0.9,
  },
  {
    sectionId: 10,
    name: "Dual/Multiple Citizenship & Foreign Passport Info",
    pageRanges: [[8, 9]],
    fieldPathPatterns: [
      /Section10/,
      /section10/,
      /DualCitizenship/,
      /Section10\\\.1-10\\\.2/,
      /^form1\[0\]\.Section10/,
    ],
    valueKeywords: [
      "sect10",
      "dual",
      "second",
      "citizenship",
      "passport",
      "foreign",
    ],
    contextKeys: ["form1[0].Section10", "form1[0].Section10.1-10.2"],
    neighborFields: ["dualCitizenship", "foreignPassport", "foreignCountry"],
    confidence: 0.9,
  },

  {
    sectionId: 11,
    name: "Where You Have Lived",
    pageRanges: [[10, 13]],
    fieldPathPatterns: [
      /Section11/,
      /section11/,
      /Residence/,
      /section11/,
      /^form1\[0\]\.section11/,
    ],
    valueKeywords: [
      "sect11",
      "residence",
      "address",
      "live",
      "landlord",
      "verifier",
    ],
    contextKeys: ["form1[0].section11"],
    neighborFields: [
      "residenceStreet",
      "residenceCity",
      "residenceState",
      "residenceZipCode",
    ],
    confidence: 0.85,
  },

  {
    sectionId: 12,
    name: "Where you went to School",
    pageRanges: [[14, 16]],
    fieldPathPatterns: [
      /Section12/,
      /section12/,
      /Education/,
      /section12/,
      /^form1\[0\]\.section12/,
    ],
    valueKeywords: [
      "sect12",
      "school",
      "college",
      "university",
      "education",
      "degree",
      "diploma",
    ],
    contextKeys: ["form1[0].section12"],
    neighborFields: [
      "schoolName",
      "degreeType",
      "graduationDate",
      "majorField",
    ],
    confidence: 0.85,
  },

  {
    sectionId: 13,
    name: "Employment Acitivites",
    pageRanges: [[17, 33]],
    fieldPathPatterns: [
      /Section13/,
      /section13/,
      /Employment/,
      /section13/,
      /^form1\[0\]\.section13/,
    ],
    valueKeywords: [
      "sect13",
      "employer",
      "job",
      "employment",
      "work",
      "position",
      "supervisor",
    ],
    contextKeys: ["form1[0].section13"],
    neighborFields: [
      "employerName",
      "jobTitle",
      "startDate",
      "endDate",
      "supervisorName",
    ],
    confidence: 0.85,
  },
  {
    sectionId: 14,
    name: "Selective Service",
    pageRanges: [[34, 34]],
    fieldPathPatterns: [
      /Section14/,
      /section14/,
      /SelectiveService/,
      /Section14/,
      /^form1\[0\]\.Section14/,
    ],
    valueKeywords: [
      "sect14",
      "selective",
      "service",
      "registration",
      "military",
      "draft",
    ],
    contextKeys: ["form1[0].Section14"],
    neighborFields: ["registrationNumber", "registrationDate", "exemption"],
    confidence: 0.85,
  },

  {
    sectionId: 15,
    name: "Military History",
    pageRanges: [[34, 37]],
    fieldPathPatterns: [
      /Section15/,
      /section15/,
      /MilitaryHistory/,
      /Section15/,
      /^form1\[0\]\.Section15/,
    ],
    valueKeywords: [
      "sect15",
      "military",
      "service",
      "branch",
      "discharge",
      "rank",
      "officer",
    ],
    contextKeys: ["form1[0].Section15"],
    neighborFields: [
      "branchOfService",
      "serviceNumber",
      "rankAtDischarge",
      "typeOfDischarge",
    ],
    confidence: 0.85,
  },

  {
    sectionId: 16,
    name: "People Who Know You Well",
    pageRanges: [[38, 38]],
    fieldPathPatterns: [
      /Section16/,
      /section16/,
      /PeopleWhoKnowYouWell/,
      /section_16/,
      /^form1\[0\]\.section_16/,
    ],
    valueKeywords: [
      "sect16",
      "reference",
      "know",
      "contact",
      "relationship",
      "acquaintance",
    ],
    contextKeys: ["form1[0].section_16"],
    neighborFields: ["referenceName", "referencePhone", "relationshipType"],
    confidence: 0.9,
  },

  {
    sectionId: 17,
    name: "Maritial/Relationship Status",
    pageRanges: [[39, 44]],
    fieldPathPatterns: [
      /Section17/,
      /section17/,
      /AlienRegistration/,
      /Section17/,
      /^form1\[0\]\.Section17/,
    ],
    valueKeywords: [
      "sect",
      "marital",
      "relationship",
      "spouse",
      "partner",
      "child",
    ],
    contextKeys: ["form1[0].Section17"],
    neighborFields: [
      "maritalStatus",
      "spouseName",
      "spouseBirthDate",
      "spouseSSN",
    ],
    confidence: 0.9,
  },

  {
    sectionId: 18,
    name: "Relatives",
    pageRanges: [[45, 62]],
    fieldPathPatterns: [
      /Section18/,
      /section18/,
      /Relatives/,
      /Section18/,
      /^form1\[0\]\.Section18/,
    ],
    valueKeywords: [
      "sect18",
      "marital",
      "relationship",
      "spouse",
      "partner",
      "child",
    ],
    contextKeys: ["form1[0].Section17"],
    neighborFields: ["spouseName", "spouseBirthDate", "spouseSSN"],
    confidence: 0.9,
  },

  {
    sectionId: 19,
    name: "Foreign Contacts",
    pageRanges: [[63, 66]],
    fieldPathPatterns: [
      /Section19/,
      /section19/,
      /ForeignContacts/,
      /Section19/,
      /^form1\[0\]\.Section19/,
    ],
    valueKeywords: [
      "sect1",
      "foreign",
      "contact",
      "relationship",
      "citizen",
      "allegiance",
    ],
    contextKeys: ["form1[0].Section19"],
    neighborFields: ["contactName", "relationship", "country", "affiliation"],
    confidence: 0.85,
  },
  {
    sectionId: 20,
    name: "Foreign Business, Activities, Government Contacts",
    pageRanges: [[39, 68]],
    fieldPathPatterns: [
      /Section20/,
      /section20/,
      /ForeignActivities/,
      /Section20/,
      /^form1\[0\]\.Section20/,
    ],
    valueKeywords: [
      "sect19",
      "foreign",
      "activity",
      "travel",
      "passport",
      "visa",
      "border",
    ],
    contextKeys: ["form1[0].Section20"],
    neighborFields: ["travelDate", "countryVisited", "purpose", "contactsMade"],
    confidence: 0.85,
  },
  {
    sectionId: 21,
    name: "Psycological and Emotional Health",
    pageRanges: [[43, 97]],
    fieldPathPatterns: [
      /Section21/,
      /section21/,
      /ForeignBusiness/,
      /Section21/,
      /^form1\[0\]\.Section21/,
    ],
    valueKeywords: [
      "sect21",
      "foreign",
      "business",
      "investment",
      "property",
      "meeting",
      "conference",
    ],
    contextKeys: ["form1[0].Section21"],
    neighborFields: [
      "businessName",
      "businessType",
      "ownership",
      "financialInterest",
    ],
    confidence: 0.8,
  },

  {
    sectionId: 22,
    name: "Police Record",
    pageRanges: [[98, 104]],
    fieldPathPatterns: [
      /Section22/,
      /section22/,
      /PublicRecord/,
      /Section22/,
      /^form1\[0\]\.Section22/,
    ],
    valueKeywords: [
      "sect22",
      "record",
      "public",
      "disclosure",
      "search",
      "information",
      "available",
    ],
    contextKeys: ["form1[0].Section22"],
    neighborFields: ["recordType", "recordLocation", "recordContent"],
    confidence: 0.8,
  },

  {
    sectionId: 23,
    name: "Illegal Use of Drugs and Drug Activity",
    pageRanges: [[105, 111]],
    fieldPathPatterns: [
      /Section23/,
      /section23/,
      /DrugsUse/,
      /Section23/,
      /^form1\[0\]\.Section23/,
    ],
    valueKeywords: [
      "sect23",
      "drug",
      "substance",
      "abuse",
      "misuse",
      "illegal",
      "narcotic",
    ],
    contextKeys: ["form1[0].Section23"],
    neighborFields: ["substanceType", "useDate", "frequency", "treatment"],
    confidence: 0.8,
  },

  {
    sectionId: 24,
    name: "Use of Alcohol",
    pageRanges: [[112, 115]],
    fieldPathPatterns: [
      /Section24/,
      /section24/,
      /Alcohol/,
      /Section24/,
      /Section_23/,
      /^form1\[0\]\.Section24/,
      /^form1\[0\]\.Section_23/,
    ],
    valueKeywords: [
      "sect24",
      "alcohol",
      "treatment",
      "abuse",
      "counseling",
      "intoxication",
    ],
    contextKeys: ["form1[0].Section24", "form1[0].Section_23"],
    neighborFields: ["alcoholTreatment", "incidentDate", "circumstance"],
    confidence: 0.8,
  },
  {
    sectionId: 25,
    name: "Investigations and Clearance",
    pageRanges: [[116, 117]],
    fieldPathPatterns: [
      /Section25/,
      /section25/,
      /Investigations and Clearance/,
      /Section25/,
      /^form1\[0\]\.Section25/,
      /^form1\[0\]\.Section_25/,
    ],
    valueKeywords: ["sect25"],
    contextKeys: ["form1[0].Section25", "form1[0].Section_25"],
    neighborFields: [],
    confidence: 0.8,
  },
  {
    sectionId: 26,
    name: "Financial Record",
    pageRanges: [[116, 117]],
    fieldPathPatterns: [
      /Section26/,
      /section26/,
      /FinancialRecord/,
      /Section26/,
      /^form1\[0\]\.Section26/,
    ],
    valueKeywords: [
      "sect26",
      "financial",
      "bankruptcy",
      "debt",
      "delinquent",
      "tax",
      "lien",
    ],
    contextKeys: ["form1[0].Section26"],
    neighborFields: ["debtType", "amount", "resolution", "creditorName"],
    confidence: 0.8,
  },
  {
    sectionId: 28,
    name: "Involvement in Non-Criminal Court Actions",
    pageRanges: [[127, 127]],
    fieldPathPatterns: [
      /Section28/,
      /section28/,
      /CivilCourtRecord/,
      /Section28/,
      /^form1\[0\]\.Section28/,
    ],
    valueKeywords: [
      "sect28",
      "civil",
      "court",
      "legal",
      "lawsuit",
      "proceeding",
      "domestic",
    ],
    contextKeys: ["form1[0].Section28"],
    neighborFields: [
      "courtName",
      "caseNumber",
      "natureOfAction",
      "disposition",
    ],
    confidence: 0.8,
  },

  {
    sectionId: 29,
    name: "Association Record",
    pageRanges: [[68, 132]],
    fieldPathPatterns: [
      /Section29/,
      /section29/,
      /Signature/,
      /Section29/,
      /^form1\[0\]\.Section29/,
    ],
    valueKeywords: [
      "sect29",
      "signature",
      "certify",
      "attest",
      "swear",
      "date",
      "sign",
    ],
    contextKeys: ["form1[0].Section29"],
    neighborFields: ["signature", "signatureDate", "printedName"],
    confidence: 0.9,
  },
  {
    sectionId: 30,
    name: "Continuation Pages",
    pageRanges: [[133, 136]],
    fieldPathPatterns: [
      /continuation/,
      /continued/,
      /Continued/,
      /^form1\[0\]\.continuation/,
      /^form1\[0\]\..*[cC]ont(?:inue|inuation|d)/,
      /Appendix/,
      /Additional/,
    ],
    valueKeywords: [
      "sect30",
      "continuation",
      "continued",
      "additional",
      "see",
      "refer",
      "appendix",
    ],
    contextKeys: ["form1[0].continuation"],
    neighborFields: ["sectionNumber", "itemNumber", "additionalInfo"],
    confidence: 0.95,
  },
];

// Context map to hold related field groups (field names that tend to appear together)
export const contextualFieldGroups: Record<string, string[]> = {
  // Section 1 - Full Name
  personalName: ["firstName", "lastName", "middleName", "suffix", "fullName"],

  // Section 2 - Date of Birth
  birthInformation: ["birthDate", "birthMonth", "birthDay", "birthYear"],

  // Section 3 - Place of Birth
  birthLocation: ["birthCity", "birthCounty", "birthState", "birthCountry"],

  // Section 4 - Social Security Number
  identification: ["ssn", "socialSecurityNumber", "idNumber"],

  // Section 5 - Other Names Used
  alternateNames: ["otherName", "maidenName", "previousName", "aka", "alias"],

  // Section 6 - Current Address
  currentAddress: ["street", "city", "state", "zipCode", "county", "country"],
  physicalTraits: [
    "height",
    "weight",
    "hairColor",
    "eyeColor",
    "sex",
    "gender",
  ],

  // Section 7 - Contact Information
  contactInfo: [
    "homePhone",
    "cellPhone",
    "workPhone",
    "email",
    "alternateEmail",
  ],

  // Section 8 - Passport Information
  passportInfo: [
    "passportNumber",
    "passportIssueDate",
    "passportExpirationDate",
  ],

  // Section 9 & 10 - Citizenship
  citizenshipInfo: [
    "citizenship",
    "birthCertificate",
    "naturalizationCertificate",
    "dualCitizenship",
  ],

  // Section 11 - Alien Registration
  immigrationInfo: [
    "alienRegistration",
    "visaType",
    "i94Number",
    "immigrationStatus",
  ],

  // Section 12 - References
  references: [
    "referenceName",
    "referencePhone",
    "referenceEmail",
    "relationshipType",
    "yearsKnown",
  ],

  // Section 13 - Residence History
  residenceHistory: [
    "residentFrom",
    "residentTo",
    "address",
    "landlordName",
    "landlordPhone",
  ],

  // Section 14 - Education
  education: [
    "schoolName",
    "degreeType",
    "graduationDate",
    "fieldOfStudy",
    "schoolLocation",
  ],

  // Section 15 & 16 - Employment
  employment: [
    "employerName",
    "positionTitle",
    "employmentFrom",
    "employmentTo",
    "supervisorName",
  ],

  // Section 17 & 18 - Military
  military: [
    "serviceNumber",
    "branch",
    "rank",
    "serviceFrom",
    "serviceTo",
    "dischargeType",
  ],

  // Section 19 & 20 - Foreign Contacts
  foreignContacts: [
    "foreignName",
    "relationship",
    "citizenship",
    "governmentAffiliation",
  ],

  // Section 21 - Foreign Business
  foreignBusiness: [
    "businessName",
    "businessType",
    "ownershipPercentage",
    "location",
  ],

  // Sections 22-24 - Medical
  medicalInfo: ["diagnosis", "treatmentDate", "providerName", "medication"],

  // Section 25 - Financial
  financialInfo: [
    "debtAmount",
    "delinquent",
    "bankruptcy",
    "taxLien",
    "garnishment",
  ],

  // Section 26 - Legal
  legalInfo: [
    "courtName",
    "caseNumber",
    "charges",
    "disposition",
    "sentencing",
  ],

  // Section 27 - Security Clearance
  clearanceInfo: [
    "clearanceType",
    "clearanceLevel",
    "grantingAgency",
    "investigationDate",
  ],

  // Section 28 - Public Record
  publicRecords: [
    "recordType",
    "recordLocation",
    "recordDate",
    "recordContent",
  ],

  // Section 29 - Certification
  certification: [
    "signature",
    "signatureDate",
    "certificationText",
    "printedName",
  ],

  // Section 30 - Continuation
  continuation: [
    "sectionNumber",
    "itemNumber",
    "additionalInformation",
    "pageReference",
  ],
};

/**
 * Enhanced multi-dimensional section categorization using all available data points
 */
export function enhancedMultiDimensionalCategorization(
  fieldName: string,
  fieldLabel: string | undefined,
  pageNum: number,
  fieldValue: string | undefined,
  neighborFields: string[] = []
): {
  section: number;
  subsection?: string;
  entry?: number;
  confidence: number;
} | null {
  // 🎯 CRITICAL: Apply high-priority protection logic FIRST for Sections7-9 fields with sect7/8/9 values
  // This ensures fields like "sect7homeEmail" get maximum confidence and correct section assignment
  if (fieldName && fieldName.includes("Sections7-9[") && fieldValue) {
    const value = fieldValue.toString().toLowerCase();

    // 🚨 DEBUG: Log when we encounter Sections7-9 fields to verify this function is being called
    console.log(`🚨 HIGH-PRIORITY DEBUG: enhancedMultiDimensionalCategorization called for ${fieldName} = "${fieldValue}"`);
    console.log(`   Processed value: "${value}"`);
    console.log(`   Contains sect7: ${value.includes("sect7")}`);
    console.log(`   Contains sect8: ${value.includes("sect8")}`);
    console.log(`   Contains sect9: ${value.includes("sect9")}`);

    // Check for sect7, sect8, or sect9 values and assign to correct sections with maximum confidence
    if (value.includes("sect7")) {
      console.log(`   ✅ RETURNING SECTION 7 with confidence 0.99`);
      return {
        section: 7,
        confidence: 0.99, // Maximum confidence for explicit value-based matching
      };
    }
    if (value.includes("sect8")) {
      console.log(`   ✅ RETURNING SECTION 8 with confidence 0.99`);
      return {
        section: 8,
        confidence: 0.99, // Maximum confidence for explicit value-based matching
      };
    }
    if (value.includes("sect9")) {
      console.log(`   ✅ RETURNING SECTION 9 with confidence 0.99`);
      return {
        section: 9,
        confidence: 0.99, // Maximum confidence for explicit value-based matching
      };
    }

    console.log(`   ❌ NO SECT7/8/9 MATCH - proceeding to regular categorization`);
  }

  // OPTIMIZATION: Check for complex pattern match first
  // This gives precedence to precise pattern matching before more generic heuristics
  const complexInfo = extractSectionInfoFromName(fieldName);
  if (complexInfo?.section && complexInfo.confidence >= 0.95) {
    // If we have a high-confidence match from the pattern extraction, use it directly
    return {
      section: complexInfo.section,
      subsection: complexInfo.subsection,
      entry: complexInfo.entry,
      confidence: complexInfo.confidence,
    };
  }

  // Track the best match with its confidence score
  let bestMatch: {
    section: number;
    subsection?: string;
    entry?: number;
    confidence: number;
  } | null = null;

  // Calculate scores for each section based on multiple dimensions
  for (const classification of sectionClassifications) {
    let score = 0;
    let matches = 0;
    let totalFactors = 0;

    // 1. Page number matching (highest weight)
    if (pageNum > 0) {
      totalFactors += 3; // Page factor has triple weight

      // Check if page falls within any of the section's page ranges
      const pageMatch = classification.pageRanges.some(
        ([start, end]) => pageNum >= start && pageNum <= end
      );

      if (pageMatch) {
        score += 3; // Triple weight for page match
        matches++;
      }
    }

    // 2. Field path pattern matching
    if (fieldName) {
      totalFactors += 2; // Field name has double weight

      // Check if field name matches any of the section's patterns
      const nameMatch = classification.fieldPathPatterns.some((pattern) =>
        pattern.test(fieldName)
      );

      if (nameMatch) {
        score += 2; // Double weight for name match
        matches++;
      }
    }

    // 4. Field value keyword matching
    if (fieldValue && typeof fieldValue === "string" && fieldValue.length > 0) {
      totalFactors += 1;

      // Check if value contains any section keywords
      const valueMatch = classification.valueKeywords.some((keyword) =>
        fieldValue.toLowerCase().includes(keyword.toLowerCase())
      );

      if (valueMatch) {
        score += 1;
        matches++;
      }
    }

    // 5. Context keys matching
    if (fieldName) {
      totalFactors += 1;

      // Check if field name is one of the context keys for this section
      const contextMatch = classification.contextKeys.some((contextKey) =>
        fieldName.includes(contextKey)
      );

      if (contextMatch) {
        score += 1;
        matches++;
      }
    }

    // 6. Neighbor fields matching
    if (neighborFields.length > 0) {
      totalFactors += 1;

      // Count how many neighbor fields match this section's neighbor fields
      const neighborMatches = neighborFields.filter((neighbor) =>
        classification.neighborFields.some((expectedNeighbor) =>
          neighbor.toLowerCase().includes(expectedNeighbor.toLowerCase())
        )
      ).length;

      // Calculate a proportional score based on matches
      if (neighborMatches > 0) {
        const proportionalScore = Math.min(
          1,
          neighborMatches / Math.min(5, classification.neighborFields.length)
        );
        score += proportionalScore;
        matches++;
      }
    }

    // Calculate confidence as a combination of:
    // 1. The section's base confidence level
    // 2. The proportion of matching factors
    // 3. The strength of the matches

    // Prevent division by zero
    if (totalFactors === 0) totalFactors = 1;

    // Calculate match confidence
    const matchProportion = score / totalFactors;
    const factorMatch = matches / Math.min(5, totalFactors);

    // Final confidence is a weighted average of base confidence and match proportion
    const confidence =
      0.4 * classification.confidence +
      0.4 * matchProportion +
      0.2 * factorMatch;

    // Update best match if this section has higher confidence
    if (!bestMatch || confidence > bestMatch.confidence) {
      // Get section ID from classification
      const sectionId = classification.sectionId;

      // Try to extract subsection and entry information
      // If we have lower confidence match from pattern extraction, use it
      let subsection: string | undefined = undefined;
      let entry: number | undefined = undefined;

      if (complexInfo && complexInfo.section === sectionId) {
        subsection = complexInfo.subsection;
        entry = complexInfo.entry;
      } else {
        // Try to extract subsection and entry from the field name
        // This handles cases where the field name contains subsection/entry info
        // but wasn't matched with high confidence in the first pass

        // For entry detection in specific sections:
        if (sectionId >= 1 && sectionId <= 8) {
          // Lower-numbered sections (1-8) typically don't have subsections
          // Look for entry patterns
          const entryMatch = fieldName.match(/entry[_\s]?(\d+)/i) ||
                            fieldName.match(/instance[_\s]?(\d+)/i);

          entry = entryMatch ? parseInt(entryMatch[1]) : 0; // Default to entry 0 for base content
        } else {
          // Higher-numbered sections (9+) may have both subsections and entries
          // Look for subsection patterns first
          const subsectionMatch = fieldName.match(/subsection[_\s]?([A-Za-z])/i) ||
                                  fieldName.match(/sub[_\s]?([A-Za-z])/i);

          if (subsectionMatch) {
            subsection = subsectionMatch[1].toUpperCase();

            // If we found a subsection, look for entry
            const entryMatch = fieldName.match(/entry[_\s]?(\d+)/i) ||
                              fieldName.match(/instance[_\s]?(\d+)/i);

            entry = entryMatch ? parseInt(entryMatch[1]) : 1; // Default to entry 1 for first instance
          }
        }
      }

      bestMatch = {
        section: sectionId,
        subsection,
        entry,
        confidence,
      };
    }
  }

  return bestMatch;
}

/**
 * Extract context from neighboring fields
 */
export function getNeighborFieldContext(
  fieldName: string,
  allFields: string[]
): string[] {
  // Get fields that appear nearby in the form structure
  // This is a simplistic approach - ideally we'd have x,y coordinates from the PDF

  // Normalize field name for pattern matching
  const normalizedName = fieldName.replace(/\[\d+\]/g, "[i]");

  // Find fields with similar patterns
  const similarFields = allFields.filter((f) => {
    const normalizedF = f.replace(/\[\d+\]/g, "[i]");
    // Check if they share a common prefix
    if (normalizedF.length > 5 && normalizedName.length > 5) {
      const prefix = normalizedF.substring(
        0,
        Math.min(normalizedF.lastIndexOf("["), normalizedF.lastIndexOf("."))
      );
      return normalizedName.startsWith(prefix);
    }
    return false;
  });

  // Find context group this field might belong to
  const contextGroup = Object.entries(contextualFieldGroups).find(
    ([_, fields]) =>
      fields.some((field) =>
        fieldName.toLowerCase().includes(field.toLowerCase())
      )
  )?.[0];

  // If context group found, return all fields from that group that exist in allFields
  if (contextGroup) {
    const groupFields = contextualFieldGroups[contextGroup];
    return allFields.filter((f) =>
      groupFields.some((field) => f.toLowerCase().includes(field.toLowerCase()))
    );
  }

  return similarFields;
}

/**
 * Get the field metadata including page, section, value and context information
 */
export function getComprehensiveFieldMetadata(
  fieldName: string,
  allFields: string[],
  fieldValueGetter?: (name: string) => any,
  fieldLabelGetter?: (name: string) => string | undefined
): {
  name: string;
  page: number;
  section: number;
  subsection?: string;
  entry?: number;
  value?: any;
  label?: string;
  neighborFields: string[];
  confidence: number;
} {
  // Get page number
  const page = getFieldPage(fieldName);

  // Get label if available
  const label = fieldLabelGetter ? fieldLabelGetter(fieldName) : undefined;

  // Get value if available
  const value = fieldValueGetter ? fieldValueGetter(fieldName) : undefined;

  // Get neighbor fields
  const neighborFields = getNeighborFieldContext(fieldName, allFields);

  // Categorize the field
  const categorization = enhancedMultiDimensionalCategorization(
    fieldName,
    label,
    page,
    value ? String(value) : undefined,
    neighborFields
  );

  return {
    name: fieldName,
    page,
    section: categorization?.section || 0,
    subsection: categorization?.subsection,
    entry: categorization?.entry,
    value,
    label,
    neighborFields,
    confidence: categorization?.confidence || 0,
  };
}

/**
 * Group fields by section using the comprehensive categorization
 */
export function groupFieldsBySection(
  fieldNames: string[],
  fieldValueGetter?: (name: string) => any,
  fieldLabelGetter?: (name: string) => string | undefined
): Record<
  number,
  {
    sectionName: string;
    fields: Array<{
      name: string;
      page: number;
      subsection?: string;
      entry?: number;
      value?: any;
      label?: string;
      confidence: number;
    }>;
  }
> {
  const sections: Record<
    number,
    {
      sectionName: string;
      fields: Array<{
        name: string;
        page: number;
        subsection?: string;
        entry?: number;
        value?: any;
        label?: string;
        confidence: number;
      }>;
    }
  > = {};

  // Initialize sections
  for (const classification of sectionClassifications) {
    sections[classification.sectionId] = {
      sectionName: classification.name,
      fields: [],
    };
  }

  // Categorize each field
  for (const fieldName of fieldNames) {
    const metadata = getComprehensiveFieldMetadata(
      fieldName,
      fieldNames,
      fieldValueGetter,
      fieldLabelGetter
    );

    if (metadata.section > 0 && metadata.confidence > 0.5) {
      sections[metadata.section].fields.push({
        name: metadata.name,
        page: metadata.page,
        subsection: metadata.subsection,
        entry: metadata.entry,
        value: metadata.value,
        label: metadata.label,
        confidence: metadata.confidence,
      });
    }
  }

  return sections;
}

// Export the new functions in the default export
export default {
  // Existing exports
  initPageCategorization,
  enhancedCategorizeField,
  updateFieldWithPageData,
  getFieldPage,
  identifySectionByPage,
  identifySectionByField,
  enhancedSectionCategorization,
  loadFieldPageMapping,
  loadSectionStats,
  refinedSectionPageRanges,
  extractSectionInfoFromName,
  createEmptyFieldPageMapping,
  createEmptySectionStats,
  getSectionPageRange,
  getFieldsForSection,
  getFieldPattern,
  generateMinimalMetadata,
  sectionFieldPatterns,

  // New comprehensive multi-dimensional categorization functions
  sectionClassifications,
  contextualFieldGroups,
  enhancedMultiDimensionalCategorization,
  getNeighborFieldContext,
  getComprehensiveFieldMetadata,
  groupFieldsBySection,
};
