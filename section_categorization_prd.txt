# Section & Sub‑Section Field Categorization – **PRD v0.1**

> **Project codename:** _SF‑86 Sectionizer_
> **Owner:** T J  |  **Tech Stack:** TypeScript (© npx tsx), Node 18, Playwright MCP (optional), pnpm
> **Repo root:** `clarance-f/`

---

## 1 – Objective
Design an **auto‑classifying pipeline** that ingests raw PDF field metadata (6197+ ids from *sf862.pdf*), assigns every field to **exactly one** of the 30 SF‑86 sections, and—where applicable—to its **sub‑section & entry index** (e.g. `21‑D‑3`).  
Any field that cannot be resolved in the first pass is written to `scripts/unknown.json`, and the algorithm iterates until that file is empty.

## 2 – Scope
* **In‑scope** – CLI utilities under `scripts/` & `utilities/` that read PDF dictionaries, categorise fields, generate per‑section artefacts, and emit diagnostic reports.
* **Out‑of‑scope** – UI rendering, Redux wiring, form validation (handled elsewhere by `formHandler.tsx`).

## 3 – Key Requirements
| # | Requirement | Priority |
|---|-------------|----------|
| R1 | **Complete Coverage** – all 30 sections must be represented even if zero fields are present. | P0 |
| R2 | **Sub‑Section Parsing** – detect patterns like `section21d3`, `21D.1`, `Section5bEntry2`, etc. | P0 |
| R3 | **Iterative Self‑Healing** – unknown fields funnel to `unknown.json`; on the next run the engine re‑evaluates and re‑classifies based on newly derived rules. | P0 |
| R4 | **Config‑Driven Rules** – each section owns a `rules.ts` matrix (regex → {subSection, entry}) so behaviour is transparent & overrideable. | P1 |
| R5 | **Fail‑Safe Confidence Metric** – avoid ÷0 when section = 0 fields; report confidence per section. | P1 |
| R6 | **Rich Reporting** – emit `reports/sectionizer‑report.md` summarising stats (categorised, uncategorised, confidence). | P2 |

## 4 – Workflow Overview
```mermaid
graph TD;
  A[extractFieldsBySection.ts] -->|raw field list| B(enhanced-pdf-validation.ts);
  B --> C{rule‑engine};
  C -->|match| D[scripts/mySections/<section>.json];
  C -->|no‑match| E[unknown.json];
  E --> F{rules‑generator};
  F -->|new/updated regex| rules.ts;
  rules.ts --> C;
```
1. **Extraction (A)** – load all field objects `{ id, name, value, page }`.
2. **Validation (B)** – enrich with page & label heuristics from `page-categorization-bridge.ts`.
3. **Rule Engine (C)** – apply section‑specific regex maps.
4. **Emit** per‑section JSON artefacts to `scripts/mySections/` (sub‑sections nested).
5. **Unknown Funnel (E)** – unresolved → `unknown.json`.
6. **Rule Generator (F)** – analyse patterns in `unknown.json`, propose rule diffs, append to appropriate `rules.ts`; repeat until `unknown.json` is empty or unchanged on two successive runs.

## 5 – Section Rule Strategy
* **File:** `src/sectionizer/rules/<section>.rules.ts`
* **Export contract:**
  ```ts
  interface MatchRule {
    pattern: RegExp;          // e.g. /^section21d(\d+)$/i
    subSection: string;       // "D"
    entryIndex?: (m: RegExpMatchArray) => number;
  }
  export const rules: MatchRule[] = [...];
  ```
* **Ordering:** evaluated top‑down – specific → generic.
* **Fallback:** if no regex matches, invoke `bridge.pageRangeLookup(page)`.

### 5.1 Example – Section 21
| Regex | Sub‑Section | Entry resolver |
|-------|-------------|----------------|
| `/^section21d(\d+)$/i` | `D` | `m => Number(m[1])` |
| `/^21d\.?(\d+)$/i` | `D` | `m => Number(m[1])` |
| `/^section21c$/i` | `C` | `() => 1 /* consolidated */` |
| `/^section21a(\d*)$/i` | `A` | `m => m[1] ? Number(m[1]) : 1` |
| `/^section21e(\d*)$/i` | `E` | `m => m[1] ? Number(m[1]) : 1` |

### 5.2 Zero‑Sub‑Section Sections
If `rules.length === 0`, classify all incoming fields under `"_default"` and set `meta.hasSubSections = false`.

## 6 – File & Directory Layout
```
clarance-f/
└─ src/
   └─ sectionizer/
      ├─ index.ts              # CLI entry (npx tsx)  
      ├─ engine.ts             # core rule‑engine  
      ├─ rules/                # 30× <section>.rules.ts  
      └─ utils/bridgeAdapter.ts
└─ scripts/
   ├─ mySections/              # output per run  
   └─ unknown.json             # temp uncategorised dump
└─ reports/
   └─ sectionizer-report.md
```

## 7 – Algorithm Details
1. **Pre‑pass normalisation** – strip whitespace, convert to lower‑snake, remove trailing `0 R`.
2. **Rule evaluation** – run through `rules` array; first match wins.
3. **Confidence score** – `conf = matched / totalFieldsInSection` (0‑1).
4. **Unknown handling** – serialise to `unknown.json` (keep history if `--keep-unknown` flag).
5. **Self‑healing loop** – `while (unknown.size && attempts < 5)` generate candidate regexes via:
   * common prefixes/suffixes clustering
   * Levenshtein distance to known fields
   * page‑range bridge hints

## 8 – Testing & QA
* **Unit tests** in `tests/sectionizer/*.test.ts` – regex accuracy, bridge fall‑back.
* **Integration** – run against *sf862.pdf*, expect `unknown.json` to be empty within ≤ 3 iterations.
* **Playwright MCP** (optional) – screenshot each field highlight, compare to expected HTML overlay.

## 9 – Acceptance Criteria
- [ ] All 6197 fields appear in **exactly one** section file.
- [ ] `unknown.json` is empty after pipeline finishes.
- [ ] `sectionizer-report.md` lists 30 sections, confidence ≥ 95 % each.
- [ ] Pipeline completes in < 120 s on Mac M‑series.

## 10 – Future Enhancements
* YAML‑based rule config to decouple from TS.
* `--watch` mode for live dev‑loop.
* GraphQL resolver to expose section data downstream.

---
*Last updated 2025‑05‑16 by ChatGPT (o3).*